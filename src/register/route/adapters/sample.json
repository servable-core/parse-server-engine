{
  _readableState: {
    state: 137266,
    highWaterMark: 16384,
    buffer: {
      head: null,
      tail: null,
      length: 0,
    },
    length: 0,
    pipes: [],
    flowing: null,
    errored: null,
    defaultEncoding: "utf8",
    awaitDrainWriters: null,
    decoder: null,
    encoding: null,
  },
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  socket: {
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: null,
    _closeAfterHandlingError: false,
    _readableState: {
      state: 4184,
      highWaterMark: 16384,
      buffer: {
        head: null,
        tail: null,
        length: 0,
      },
      length: 0,
      pipes: [],
      flowing: true,
      errored: null,
      defaultEncoding: "utf8",
      awaitDrainWriters: null,
      decoder: null,
      encoding: null,
    },
    _events: {
      end: [
        function onReadableStreamEnd() {
          if (!this.allowHalfOpen) {
            this.write = writeAfterFIN;
          }
        },
        function () {
          [native code
          ]
        },
      ],
      timeout: function socketOnTimeout() {
        const req = this.parser && this.parser.incoming;
        const reqTimeout = req && !req.complete && req.emit('timeout', this);
        const res = this._httpMessage;
        const resTimeout = res && res.emit('timeout', this);
        const serverTimeout = this.server.emit('timeout', this);

        if (!reqTimeout && !resTimeout && !serverTimeout)
          this.destroy();
      },
      data: function () {
        [native code
        ]
      },
      error: function socketOnError(e) {
        // Ignore further errors
        this.removeListener('error', socketOnError);

        if (this.listenerCount('error', noop) === 0) {
          this.on('error', noop);
        } else {
          warnUnclosedSocket();
        }

        if (!this.server.emit('clientError', e, this)) {
          // Caution must be taken to avoid corrupting the remote peer.
          // Reply an error segment if there is no in-flight `ServerResponse`,
          // or no data of the in-flight one has been written yet to this socket.
          if (this.writable &&
              (!this._httpMessage || !this._httpMessage._headerSent)) {
            let response;

            switch (e.code) {
              case 'HPE_HEADER_OVERFLOW':
                response = requestHeaderFieldsTooLargeResponse;
                break;
              case 'HPE_CHUNK_EXTENSIONS_OVERFLOW':
                response = requestChunkExtensionsTooLargeResponse;
                break;
              case 'ERR_HTTP_REQUEST_TIMEOUT':
                response = requestTimeoutResponse;
                break;
              default:
                response = badRequestResponse;
                break;
            }

            this.write(response);
          }
          this.destroy(e);
        }
      },
      close: [
        function () {
          [native code
          ]
        },
        function onServerResponseClose() {
          // EventEmitter.emit makes a copy of the 'close' listeners array before
          // calling the listeners. detachSocket() unregisters onServerResponseClose
          // but if detachSocket() is called, directly or indirectly, by a 'close'
          // listener, onServerResponseClose is still in that copy of the listeners
          // array. That is, in the example below, b still gets called even though
          // it's been removed by a:
          //
          //   const EventEmitter = require('events');
          //   const obj = new EventEmitter();
          //   obj.on('event', a);
          //   obj.on('event', b);
          //   function a() { obj.removeListener('event', b) }
          //   function b() { throw "BAM!" }
          //   obj.emit('event');  // throws
          //
          // Ergo, we need to deal with stale 'close' events and handle the case
          // where the ServerResponse object has already been deconstructed.
          // Fortunately, that requires only a single if check. :-)
          if (this._httpMessage) {
            emitCloseNT(this._httpMessage);
          }
        },
      ],
      drain: function () {
        [native code
        ]
      },
      resume: function onSocketResume() {
        // It may seem that the socket is resumed, but this is an enemy's trick to
        // deceive us! `resume` is emitted asynchronously, and may be called from
        // `incoming.readStart()`. Stop the socket again here, just to preserve the
        // state.
        //
        // We don't care about stream semantics for the consumed socket anyway.
        if (this._paused) {
          this.pause();
          return;
        }

        if (this._handle && !this._handle.reading) {
          this._handle.reading = true;
          this._handle.readStart();
        }
      },
      pause: function onSocketPause() {
        if (this._handle && this._handle.reading) {
          this._handle.reading = false;
          this._handle.readStop();
        }
      },
    },
    _eventsCount: 8,
    _maxListeners: undefined,
    _writableState: {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: false,
      needDrain: false,
      ending: false,
      ended: false,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: "utf8",
      length: 0,
      writing: false,
      corked: 0,
      sync: true,
      bufferProcessing: false,
      onwrite: function () {
        [native code
        ]
      },
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      buffered: [],
      bufferedIndex: 0,
      allBuffers: true,
      allNoop: true,
      pendingcb: 0,
      constructed: true,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: true,
      errored: null,
      closed: false,
      closeEmitted: false,
    },
    allowHalfOpen: true,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: "",
    server: {
      maxHeaderSize: undefined,
      insecureHTTPParser: undefined,
      requestTimeout: 300000,
      headersTimeout: 60000,
      keepAliveTimeout: 5000,
      connectionsCheckingInterval: 30000,
      joinDuplicateHeaders: undefined,
      rejectNonStandardBodyWrites: false,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
          );
        },
        listening: [
          function setupConnectionsTracking() {
            // Start connection handling
            if (!this[kConnections
            ]) {
              this[kConnections
              ] = new ConnectionsList();
            }
            // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
            // otherwise it would not be started if such timeouts are modified after createServer.
            this[kConnectionsCheckingInterval
            ] =
              setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
          },
          function () {
            [native code
            ]
          },
        ],
        error: function () {
          [native code
          ]
        },
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        },
      },
      _eventsCount: 5,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol
          ];

          debug('onconnection');

          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }

          if (self.maxConnections && self._connections >= self.maxConnections) {
            if (clientHandle.getsockname || clientHandle.getpeername) {
              const data = ObjectCreate(null);
              if (clientHandle.getsockname) {
                const localInfo = ObjectCreate(null);
                clientHandle.getsockname(localInfo);
                data.localAddress = localInfo.address;
                data.localPort = localInfo.port;
                data.localFamily = localInfo.family;
              }
              if (clientHandle.getpeername) {
                const remoteInfo = ObjectCreate(null);
                clientHandle.getpeername(remoteInfo);
                data.remoteAddress = remoteInfo.address;
                data.remotePort = remoteInfo.port;
                data.remoteFamily = remoteInfo.family;
              }
              self.emit('drop', data);
            } else {
              self.emit('drop');
            }
            clientHandle.close();
            return;
          }

          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true,
            readableHighWaterMark: self.highWaterMark,
            writableHighWaterMark: self.highWaterMark,
          });

          if (self.noDelay && clientHandle.setNoDelay) {
            socket[kSetNoDelay
            ] = true;
            clientHandle.setNoDelay(true);
          }
          if (self.keepAlive && clientHandle.setKeepAlive) {
            socket[kSetKeepAlive
            ] = true;
            socket[kSetKeepAliveInitialDelay
            ] = self.keepAliveInitialDelay;
            clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
          }

          self._connections++;
          socket.server = self;
          socket._server = self;

          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
          lazyChannels();
          if (netServerSocketChannel.hasSubscribers) {
            netServerSocketChannel.publish({
              socket,
            });
          }
        },
      },
      _usingWorkers: false,
      _workers: [],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      noDelay: true,
      keepAlive: false,
      keepAliveInitialDelay: 0,
      highWaterMark: 16384,
      httpAllowHalfOpen: false,
      timeout: 0,
      maxHeadersCount: null,
      maxRequestsPerSocket: 0,
      _connectionKey: "6::::1394",
    },
    _server: {
      maxHeaderSize: undefined,
      insecureHTTPParser: undefined,
      requestTimeout: 300000,
      headersTimeout: 60000,
      keepAliveTimeout: 5000,
      connectionsCheckingInterval: 30000,
      joinDuplicateHeaders: undefined,
      rejectNonStandardBodyWrites: false,
      _events: {
        request: function(req, res, next) {
          app.handle(req, res, next);
        },
        connection: function connectionListener(socket) {
          defaultTriggerAsyncIdScope(
            getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
          );
        },
        listening: [
          function setupConnectionsTracking() {
            // Start connection handling
            if (!this[kConnections
            ]) {
              this[kConnections
              ] = new ConnectionsList();
            }
            // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
            // otherwise it would not be started if such timeouts are modified after createServer.
            this[kConnectionsCheckingInterval
            ] =
              setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
          },
          function () {
            [native code
            ]
          },
        ],
        error: function () {
          [native code
          ]
        },
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        },
      },
      _eventsCount: 5,
      _maxListeners: undefined,
      _connections: 1,
      _handle: {
        reading: false,
        onconnection: function onconnection(err, clientHandle) {
          const handle = this;
          const self = handle[owner_symbol
          ];

          debug('onconnection');

          if (err) {
            self.emit('error', errnoException(err, 'accept'));
            return;
          }

          if (self.maxConnections && self._connections >= self.maxConnections) {
            if (clientHandle.getsockname || clientHandle.getpeername) {
              const data = ObjectCreate(null);
              if (clientHandle.getsockname) {
                const localInfo = ObjectCreate(null);
                clientHandle.getsockname(localInfo);
                data.localAddress = localInfo.address;
                data.localPort = localInfo.port;
                data.localFamily = localInfo.family;
              }
              if (clientHandle.getpeername) {
                const remoteInfo = ObjectCreate(null);
                clientHandle.getpeername(remoteInfo);
                data.remoteAddress = remoteInfo.address;
                data.remotePort = remoteInfo.port;
                data.remoteFamily = remoteInfo.family;
              }
              self.emit('drop', data);
            } else {
              self.emit('drop');
            }
            clientHandle.close();
            return;
          }

          const socket = new Socket({
            handle: clientHandle,
            allowHalfOpen: self.allowHalfOpen,
            pauseOnCreate: self.pauseOnConnect,
            readable: true,
            writable: true,
            readableHighWaterMark: self.highWaterMark,
            writableHighWaterMark: self.highWaterMark,
          });

          if (self.noDelay && clientHandle.setNoDelay) {
            socket[kSetNoDelay
            ] = true;
            clientHandle.setNoDelay(true);
          }
          if (self.keepAlive && clientHandle.setKeepAlive) {
            socket[kSetKeepAlive
            ] = true;
            socket[kSetKeepAliveInitialDelay
            ] = self.keepAliveInitialDelay;
            clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
          }

          self._connections++;
          socket.server = self;
          socket._server = self;

          DTRACE_NET_SERVER_CONNECTION(socket);
          self.emit('connection', socket);
          lazyChannels();
          if (netServerSocketChannel.hasSubscribers) {
            netServerSocketChannel.publish({
              socket,
            });
          }
        },
      },
      _usingWorkers: false,
      _workers: [],
      _unref: false,
      allowHalfOpen: true,
      pauseOnConnect: false,
      noDelay: true,
      keepAlive: false,
      keepAliveInitialDelay: 0,
      highWaterMark: 16384,
      httpAllowHalfOpen: false,
      timeout: 0,
      maxHeadersCount: null,
      maxRequestsPerSocket: 0,
      _connectionKey: "6::::1394",
    },
    parser: {
      "0": null,
      "1": function parserOnHeaders(headers, url) {
        // Once we exceeded headers limit - stop collecting them
        if (this.maxHeaderPairs <= 0 ||
            this._headers.length < this.maxHeaderPairs) {
          this._headers.push(...headers);
        }
        this._url += url;
      },
      "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
        url, statusCode, statusMessage, upgrade,
        shouldKeepAlive) {
        const parser = this;
        const { socket
        } = parser;

        if (headers === undefined) {
        headers = parser._headers;
        parser._headers = [];
        }

        if (url === undefined) {
        url = parser._url;
        parser._url = '';
        }
        // Parser is also used by http client
        const ParserIncomingMessage = (socket && socket.server &&
        socket.server[kIncomingMessage
        ]) ||
        IncomingMessage;

        const incoming = parser.incoming = new ParserIncomingMessage(socket);
        incoming.httpVersionMajor = versionMajor;
        incoming.httpVersionMinor = versionMinor;
        incoming.httpVersion = `${versionMajor
        }.${versionMinor
        }`;
        incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
         parser.joinDuplicateHeaders;
        incoming.url = url;
        incoming.upgrade = upgrade;

        let n = headers.length;

        // If parser.maxHeaderPairs <= 0 assume that there's no limit.
        if (parser.maxHeaderPairs > 0)
        n = MathMin(n, parser.maxHeaderPairs);

        incoming._addHeaderLines(headers, n);

        if (typeof method === 'number') {
          // server only
        incoming.method = methods[method
          ];
        } else {
          // client only
        incoming.statusCode = statusCode;
        incoming.statusMessage = statusMessage;
        }

        return parser.onIncoming(incoming, shouldKeepAlive);
      },
      "3": function parserOnBody(b) {
        const stream = this.incoming;

        // If the stream has already been removed, then drop it.
        if (stream === null)
          return;

        // Pretend this was the result of a stream._read call.
        if (!stream._dumped) {
          const ret = stream.push(b);
          if (!ret)
            readStop(this.socket);
        }
      },
      "4": function parserOnMessageComplete() {
        const parser = this;
        const stream = parser.incoming;

        if (stream !== null) {
          stream.complete = true;
          // Emit any trailing headers.
          const headers = parser._headers;
          if (headers.length) {
            stream._addHeaderLines(headers, headers.length);
            parser._headers = [];
            parser._url = '';
          }
          // For emit end event
          stream.push(null);
        }
        // Force to read the next incoming message
        readStart(parser.socket);
      },
      "5": function () {
        [native code
        ]
      },
      "6": function () {
        [native code
        ]
      },
      _headers: [],
      _url: "",
      socket: [Circular
      ],
      incoming: {
        _readableState: {
          state: 137266,
          highWaterMark: 16384,
          buffer: {
            head: null,
            tail: null,
            length: 0,
          },
          length: 0,
          pipes: [],
          flowing: null,
          errored: null,
          defaultEncoding: "utf8",
          awaitDrainWriters: null,
          decoder: null,
          encoding: null,
        },
        _events: {},
        _eventsCount: 0,
        _maxListeners: undefined,
        socket: [Circular
        ],
        httpVersionMajor: 1,
        httpVersionMinor: 1,
        httpVersion: "1.1",
        complete: true,
        rawHeaders: [
          "Accept",
          "application/json, text/plain, */* ",
          "User-Agent",
          "axios/0.24.0",
          "Host",
          "abounak.local:1394",
          "Connection",
          "close",
        ],
        rawTrailers: [],
          joinDuplicateHeaders: null,
            aborted: false,
              upgrade: false,
                url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                  method: "GET",
                    statusCode: null,
                      statusMessage: null,
                        client: [Circular
        ],
                          _consuming: false,
                            _dumped: false,
                              next: function next(err) {
                                var layerError = err === 'route'
                                  ? null
                                  : err;

                                // remove added slash
                                if (slashAdded) {
                                  req.url = req.url.slice(1)
                                  slashAdded = false;
          }
          // restore altered req.url
                                if (removed.length !== 0) {
                                  req.baseUrl = parentUrl;
                                  req.url = protohost + removed + req.url.slice(protohost.length)
                                  removed = '';
          }
          // signal to exit router
                                if (layerError === 'router') {
                                  setImmediate(done, null)
                                  return
          }
          // no more matching layers
                                if (idx >= stack.length) {
                                  setImmediate(done, layerError);
                                  return;
          }
          // max sync stack
                                if (++sync > 100) {
                                  return setImmediate(next, err)
          }
          // get pathname of request
                                var path = getPathname(req);

                                if (path == null) {
                                  return done(layerError);
          }
          // find next matching layer
                                var layer;
                                var match;
                                var route;

                                while (match !== true && idx < stack.length) {
                                  layer = stack[idx++
            ];
                                  match = matchLayer(layer, path);
                                  route = layer.route;

                                  if (typeof match !== 'boolean') {
              // hold on to layerError
                                    layerError = layerError || match;
            }

                                  if (match !== true) {
                                    continue;
            }

                                  if (!route) {
              // process non-route handlers normally
                                    continue;
            }

                                  if (layerError) {
              // routes do not match with a pending error
                                    match = false;
                                    continue;
            }

                                  var method = req.method;
                                  var has_method = route._handles_method(method);

                                  // build up automatic options response
                                  if (!has_method && method === 'OPTIONS') {
                                    appendMethods(options, route._options());
            }
            // don't even bother matching route
                                  if (!has_method && method !== 'HEAD') {
                                    match = false;
            }
          }
          // no match
                                if (match !== true) {
                                  return done(layerError);
          }
          // store route for dispatch on change
                                if (route) {
                                  req.route = route;
          }
          // Capture one-time layer values
                                req.params = self.mergeParams
                                  ? mergeParams(layer.params, parentParams)
                                  : layer.params;
                                var layerPath = layer.path;

                                // this should be done for the layer
                                self.process_params(layer, paramcalled, req, res, function (err) {
                                  if (err) {
                                    next(layerError || err)
            } else if (route) {
                                    layer.handle_request(req, res, next)
            } else {
                                    trim_prefix(layer, layerError, layerPath, path)
            }

                                  sync = 0
          });
        },
        baseUrl: "",
          originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
            _parsedUrl: {
          protocol: null,
            slashes: null,
              auth: null,
                host: null,
                  port: null,
                    hostname: null,
                      hash: null,
                        search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                          query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                            pathname: "/parseUserMe",
                              path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                  _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
        },
        params: {},
        query: {
          usersession: "r:255111ff859d0977bb5b94ce2782d69d",
            include: "entity",
        },
        res: {
          _events: {
            finish: function () {
              [native code
              ]
            },
          },
          _eventsCount: 1,
            _maxListeners: undefined,
              outputData: [],
                outputSize: 0,
                  writable: true,
                    destroyed: false,
                      _last: false,
                        chunkedEncoding: false,
                          shouldKeepAlive: false,
                            maxRequestsOnConnectionReached: false,
                              _defaultKeepAlive: true,
                                useChunkedEncodingByDefault: true,
                                  sendDate: true,
                                    _removedConnection: false,
                                      _removedContLen: false,
                                        _removedTE: false,
                                          strictContentLength: false,
                                            _contentLength: null,
                                              _hasBody: true,
                                                _trailer: "",
                                                  finished: false,
                                                    _headerSent: false,
                                                      _closed: false,
                                                        socket: [Circular
          ],
                                                          _header: null,
                                                            _keepAliveTimeout: 5000,
                                                              _onPendingData: function () {
            [native code
            ]
          },
          req: [Circular
          ],
            _sent100: false,
              _expect_continue: false,
                _maxRequestsPerSocket: 0,
                  locals: {},
          flush: function flush() {
            if (stream) {
              stream.flush()
            }
          },
          write: function write(chunk, encoding) {
            if (ended) {
              return false
            }

            if (!this._header) {
              this._implicitHeader()
            }

            return stream
              ? stream.write(toBuffer(chunk, encoding))
              : _write.call(this, chunk, encoding)
          },
          end: function end(chunk, encoding) {
            if (ended) {
              return false
            }

            if (!this._header) {
              // estimate the length
              if (!this.getHeader('Content-Length')) {
                length = chunkLength(chunk, encoding)
              }

              this._implicitHeader()
            }

            if (!stream) {
              return _end.call(this, chunk, encoding)
            }
            // mark ended
            ended = true
            // write Buffer for Node.js 0.8
            return chunk
              ? stream.end(toBuffer(chunk, encoding))
              : stream.end()
          },
          on: function on(type, listener) {
            if (!listeners || type !== 'drain') {
              return _on.call(this, type, listener)
            }

            if (stream) {
              return stream.on(type, listener)
            }
            // buffer listeners for future stream
            listeners.push([type, listener
            ])

            return this
          },
          writeHead: function writeHead(statusCode) {
            // set headers from arguments
            var args = setWriteHeadHeaders.apply(this, arguments)

            // fire listener
            if (!fired) {
              fired = true
              listener.call(this)

              // pass-along an updated status code
              if (typeof args[
                0
              ] === 'number' && this.statusCode !== args[
                0
              ]) {
                args[
                  0
                ] = this.statusCode
                args.length = 1
              }
            }

            return prevWriteHead.apply(this, args)
          },
          sendResponse: function send(body) {
            var chunk = body;
            var encoding;
            var req = this.req;
            var type;

            // settings
            var app = this.app;

            // allow status / body
            if (arguments.length === 2) {
              // res.send(body, status) backwards compat
              if (typeof arguments[
                0
              ] !== 'number' && typeof arguments[
                1
              ] === 'number') {
                deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                this.statusCode = arguments[
                  1
                ];
              } else {
                deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                this.statusCode = arguments[
                  0
                ];
                chunk = arguments[
                  1
                ];
              }
            }
            // disambiguate res.send(status) and res.send(status, num)
            if (typeof chunk === 'number' && arguments.length === 1) {
              // res.send(status) will set status message as text string
              if (!this.get('Content-Type')) {
                this.type('txt');
              }

              deprecate('res.send(status): Use res.sendStatus(status) instead');
              this.statusCode = chunk;
              chunk = statuses.message[chunk
              ]
            }

            switch (typeof chunk) {
              // string defaulting to html
              case 'string':
                if (!this.get('Content-Type')) {
                  this.type('html');
              }
                break;
              case 'boolean':
              case 'number':
              case 'object':
                if (chunk === null) {
                  chunk = '';
              } else if (Buffer.isBuffer(chunk)) {
                  if (!this.get('Content-Type')) {
                    this.type('bin');
                }
              } else {
                  return this.json(chunk);
              }
                break;
            }
            // write strings in utf-8
            if (typeof chunk === 'string') {
              encoding = 'utf8';
              type = this.get('Content-Type');

              // reflect this in content-type
              if (typeof type === 'string') {
                this.set('Content-Type', setCharset(type, 'utf-8'));
              }
            }
            // determine if ETag should be generated
            var etagFn = app.get('etag fn')
            var generateETag = !this.get('ETag') && typeof etagFn === 'function'

            // populate Content-Length
            var len
            if (chunk !== undefined) {
              if (Buffer.isBuffer(chunk)) {
                // get length of Buffer
                len = chunk.length
              } else if (!generateETag && chunk.length < 1000) {
                // just calculate length when no ETag + small chunk
                len = Buffer.byteLength(chunk, encoding)
              } else {
                // convert chunk to Buffer and calculate
                chunk = Buffer.from(chunk, encoding)
                encoding = undefined;
                len = chunk.length
              }

              this.set('Content-Length', len);
            }
            // populate ETag
            var etag;
            if (generateETag && len !== undefined) {
              if ((etag = etagFn(chunk, encoding))) {
                this.set('ETag', etag);
              }
            }
            // freshness
            if (req.fresh) this.statusCode = 304;

            // strip irrelevant headers
            if (204 === this.statusCode || 304 === this.statusCode) {
              this.removeHeader('Content-Type');
              this.removeHeader('Content-Length');
              this.removeHeader('Transfer-Encoding');
              chunk = '';
            }
            // alter headers for 205
            if (this.statusCode === 205) {
              this.set('Content-Length', '0')
              this.removeHeader('Transfer-Encoding')
              chunk = ''
            }

            if (req.method === 'HEAD') {
              // skip body for HEAD
              this.end();
            } else {
              // respond
              this.end(chunk, encoding);
            }

            return this;
          },
          send: (body) => {
            mcache.put(key, body, duration * 1000);
            res.sendResponse(body)
          },
        },
        body: {},
        route: {
          path: "/parseuserme",
            stack: [
            {
                handle: (req, res, next) => {
                  let key = '__express__' + req.originalUrl || req.url
                  let cachedBody = mcache.get(key)
                  if (cachedBody) {
                    res.send(cachedBody)
                    return
                } else {
                    res.sendResponse = res.send
                    res.send = (body) => {
                      mcache.put(key, body, duration * 1000);
                      res.sendResponse(body)
                  }
                    next()
                }
              },
                name: "<anonymous>",
                params: undefined,
                path: undefined,
                keys: [],
                regexp: {
                  fast_star: false,
                  fast_slash: false,
              },
                method: "get",
            },
            {
                handle: async (request, response, next) => {
                  try {
                    await Promise.resolve(fn(request, response, next)).catch(next);
                } catch (error) {
                    next(error);
                }
              },
                name: "<anonymous>",
                params: undefined,
                path: undefined,
                keys: [],
                regexp: {
                  fast_star: false,
                  fast_slash: false,
              },
                method: "get",
            },
            {
                handle: async (request, response, next) => {
                  await doHandle({ handler, request, response, next
                })
              },
                name: "<anonymous>",
                params: undefined,
                path: undefined,
                keys: [],
                regexp: {
                  fast_star: false,
                  fast_slash: false,
              },
                method: "get",
            },
          ],
              methods: {
            get: true,
          },
        },
        rateLimit: {
          limit: 1000,
            used: 1,
              remaining: 999,
                resetTime: "2024-07-19T11:30:07.125Z",
        },
      },
        outgoing: null,
          maxHeaderPairs: 2000,
            _consumed: true,
              onIncoming: function () {
        [native code
        ]
      },
        joinDuplicateHeaders: null,
    },
        on: function socketListenerWrap(ev, fn) {
          const res = net.Socket.prototype[originalFnName
      ].call(this,
            ev, fn);
          if (!this.parser) {
            this.on = net.Socket.prototype.on;
            this.addListener = net.Socket.prototype.addListener;
            this.prependListener = net.Socket.prototype.prependListener;
            return res;
      }

          if (ev === 'data' || ev === 'readable')
            unconsume(this.parser, this);

          return res;
    },
        addListener: function socketListenerWrap(ev, fn) {
          const res = net.Socket.prototype[originalFnName
      ].call(this,
            ev, fn);
          if (!this.parser) {
            this.on = net.Socket.prototype.on;
            this.addListener = net.Socket.prototype.addListener;
            this.prependListener = net.Socket.prototype.prependListener;
            return res;
      }

          if (ev === 'data' || ev === 'readable')
            unconsume(this.parser, this);

          return res;
    },
        prependListener: function socketListenerWrap(ev, fn) {
          const res = net.Socket.prototype[originalFnName
      ].call(this,
            ev, fn);
          if (!this.parser) {
            this.on = net.Socket.prototype.on;
            this.addListener = net.Socket.prototype.addListener;
            this.prependListener = net.Socket.prototype.prependListener;
            return res;
      }

          if (ev === 'data' || ev === 'readable')
            unconsume(this.parser, this);

          return res;
    },
        setEncoding: function socketSetEncoding() {
          throw new ERR_HTTP_SOCKET_ENCODING();
    },
        _paused: false,
          _httpMessage: {
          _events: {
            finish: function () {
          [native code
          ]
        },
      },
          _eventsCount: 1,
            _maxListeners: undefined,
              outputData: [],
                outputSize: 0,
                  writable: true,
                    destroyed: false,
                      _last: false,
                        chunkedEncoding: false,
                          shouldKeepAlive: false,
                            maxRequestsOnConnectionReached: false,
                              _defaultKeepAlive: true,
                                useChunkedEncodingByDefault: true,
                                  sendDate: true,
                                    _removedConnection: false,
                                      _removedContLen: false,
                                        _removedTE: false,
                                          strictContentLength: false,
                                            _contentLength: null,
                                              _hasBody: true,
                                                _trailer: "",
                                                  finished: false,
                                                    _headerSent: false,
                                                      _closed: false,
                                                        socket: [Circular
      ],
                                                          _header: null,
                                                            _keepAliveTimeout: 5000,
                                                              _onPendingData: function () {
        [native code
        ]
      },
          req: {
            _readableState: {
              state: 137266,
                highWaterMark: 16384,
                  buffer: {
                head: null,
                  tail: null,
                    length: 0,
          },
              length: 0,
                pipes: [],
                  flowing: null,
                    errored: null,
                      defaultEncoding: "utf8",
                        awaitDrainWriters: null,
                          decoder: null,
                            encoding: null,
        },
            _events: {},
            _eventsCount: 0,
              _maxListeners: undefined,
                socket: [Circular
        ],
                  httpVersionMajor: 1,
                    httpVersionMinor: 1,
                      httpVersion: "1.1",
                        complete: true,
                          rawHeaders: [
          "Accept",
          "application/json, text/plain, */*",
          "User-Agent",
          "axios/0.24.0",
          "Host",
          "abounak.local:1394",
          "Connection",
          "close",
        ],
                            rawTrailers: [],
                              joinDuplicateHeaders: null,
                                aborted: false,
                                  upgrade: false,
                                    url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                      method: "GET",
                                        statusCode: null,
                                          statusMessage: null,
                                            client: [Circular
        ],
                                              _consuming: false,
                                                _dumped: false,
                                                  next: function next(err) {
                                                    var layerError = err === 'route'
                                                      ? null
                                                      : err;

                                                    // remove added slash
                                                    if (slashAdded) {
                                                      req.url = req.url.slice(1)
                                                      slashAdded = false;
          }
          // restore altered req.url
                                                    if (removed.length !== 0) {
                                                      req.baseUrl = parentUrl;
                                                      req.url = protohost + removed + req.url.slice(protohost.length)
                                                      removed = '';
          }
          // signal to exit router
                                                    if (layerError === 'router') {
                                                      setImmediate(done, null)
                                                      return
          }
          // no more matching layers
                                                    if (idx >= stack.length) {
                                                      setImmediate(done, layerError);
                                                      return;
          }
          // max sync stack
                                                    if (++sync > 100) {
                                                      return setImmediate(next, err)
          }
          // get pathname of request
                                                    var path = getPathname(req);

                                                    if (path == null) {
                                                      return done(layerError);
          }
          // find next matching layer
                                                    var layer;
                                                    var match;
                                                    var route;

                                                    while (match !== true && idx < stack.length) {
                                                      layer = stack[idx++
            ];
                                                      match = matchLayer(layer, path);
                                                      route = layer.route;

                                                      if (typeof match !== 'boolean') {
              // hold on to layerError
                                                        layerError = layerError || match;
            }

                                                      if (match !== true) {
                                                        continue;
            }

                                                      if (!route) {
              // process non-route handlers normally
                                                        continue;
            }

                                                      if (layerError) {
              // routes do not match with a pending error
                                                        match = false;
                                                        continue;
            }

                                                      var method = req.method;
                                                      var has_method = route._handles_method(method);

                                                      // build up automatic options response
                                                      if (!has_method && method === 'OPTIONS') {
                                                        appendMethods(options, route._options());
            }
            // don't even bother matching route
                                                      if (!has_method && method !== 'HEAD') {
                                                        match = false;
            }
          }
          // no match
                                                    if (match !== true) {
                                                      return done(layerError);
          }
          // store route for dispatch on change
                                                    if (route) {
                                                      req.route = route;
          }
          // Capture one-time layer values
                                                    req.params = self.mergeParams
                                                      ? mergeParams(layer.params, parentParams)
                                                      : layer.params;
                                                    var layerPath = layer.path;

                                                    // this should be done for the layer
                                                    self.process_params(layer, paramcalled, req, res, function (err) {
                                                      if (err) {
                                                        next(layerError || err)
            } else if (route) {
                                                        layer.handle_request(req, res, next)
            } else {
                                                        trim_prefix(layer, layerError, layerPath, path)
            }

                                                      sync = 0
          });
        },
            baseUrl: "",
              originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                _parsedUrl: {
              protocol: null,
                slashes: null,
                  auth: null,
                    host: null,
                      port: null,
                        hostname: null,
                          hash: null,
                            search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                              query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                pathname: "/parseUserMe",
                                  path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                    href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                      _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
        },
            params: {},
            query: {
              usersession: "r:255111ff859d0977bb5b94ce2782d69d",
                include: "entity",
        },
            res: [Circular
        ],
              body: {},
            route: {
              path: "/parseuserme",
                stack: [
            {
                    handle: (req, res, next) => {
                      let key = '__express__' + req.originalUrl || req.url
                      let cachedBody = mcache.get(key)
                      if (cachedBody) {
                        res.send(cachedBody)
                        return
                } else {
                        res.sendResponse = res.send
                        res.send = (body) => {
                          mcache.put(key, body, duration * 1000);
                          res.sendResponse(body)
                  }
                        next()
                }
              },
                    name: "<anonymous>",
                    params: undefined,
                    path: undefined,
                    keys: [],
                    regexp: {
                      fast_star: false,
                      fast_slash: false,
              },
                    method: "get",
            },
            {
                    handle: async (request, response, next) => {
                      try {
                        await Promise.resolve(fn(request, response, next)).catch(next);
                } catch (error) {
                        next(error);
                }
              },
                    name: "<anonymous>",
                    params: undefined,
                    path: undefined,
                    keys: [],
                    regexp: {
                      fast_star: false,
                      fast_slash: false,
              },
                    method: "get",
            },
            {
                    handle: async (request, response, next) => {
                      await doHandle({ handler, request, response, next
                })
              },
                    name: "<anonymous>",
                    params: undefined,
                    path: undefined,
                    keys: [],
                    regexp: {
                      fast_star: false,
                      fast_slash: false,
              },
                    method: "get",
            },
          ],
                  methods: {
                get: true,
          },
        },
            rateLimit: {
              limit: 1000,
                used: 1,
                  remaining: 999,
                    resetTime: "2024-07-19T11:30:07.125Z",
        },
      },
          _sent100: false,
            _expect_continue: false,
              _maxRequestsPerSocket: 0,
                locals: {},
          flush: function flush() {
            if (stream) {
              stream.flush()
        }
      },
          write: function write(chunk, encoding) {
            if (ended) {
              return false
        }

            if (!this._header) {
              this._implicitHeader()
        }

            return stream
              ? stream.write(toBuffer(chunk, encoding))
              : _write.call(this, chunk, encoding)
      },
          end: function end(chunk, encoding) {
            if (ended) {
              return false
        }

            if (!this._header) {
          // estimate the length
              if (!this.getHeader('Content-Length')) {
                length = chunkLength(chunk, encoding)
          }

              this._implicitHeader()
        }

            if (!stream) {
              return _end.call(this, chunk, encoding)
        }
        // mark ended
            ended = true
        // write Buffer for Node.js 0.8
            return chunk
              ? stream.end(toBuffer(chunk, encoding))
              : stream.end()
      },
          on: function on(type, listener) {
            if (!listeners || type !== 'drain') {
              return _on.call(this, type, listener)
        }

            if (stream) {
              return stream.on(type, listener)
        }
        // buffer listeners for future stream
            listeners.push([type, listener
        ])

            return this
      },
          writeHead: function writeHead(statusCode) {
        // set headers from arguments
            var args = setWriteHeadHeaders.apply(this, arguments)

            // fire listener
            if (!fired) {
              fired = true
              listener.call(this)

              // pass-along an updated status code
              if (typeof args[
            0
          ] === 'number' && this.statusCode !== args[
            0
          ]) {
                args[
              0
            ] = this.statusCode
                args.length = 1
          }
        }

            return prevWriteHead.apply(this, args)
      },
          sendResponse: function send(body) {
            var chunk = body;
            var encoding;
            var req = this.req;
            var type;

            // settings
            var app = this.app;

            // allow status / body
            if (arguments.length === 2) {
          // res.send(body, status) backwards compat
              if (typeof arguments[
            0
          ] !== 'number' && typeof arguments[
            1
          ] === 'number') {
                deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                this.statusCode = arguments[
              1
            ];
          } else {
                deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                this.statusCode = arguments[
              0
            ];
                chunk = arguments[
              1
            ];
          }
        }
        // disambiguate res.send(status) and res.send(status, num)
            if (typeof chunk === 'number' && arguments.length === 1) {
          // res.send(status) will set status message as text string
              if (!this.get('Content-Type')) {
                this.type('txt');
          }

              deprecate('res.send(status): Use res.sendStatus(status) instead');
              this.statusCode = chunk;
              chunk = statuses.message[chunk
          ]
        }

            switch (typeof chunk) {
          // string defaulting to html
              case 'string':
                if (!this.get('Content-Type')) {
                  this.type('html');
          }
                break;
              case 'boolean':
              case 'number':
              case 'object':
                if (chunk === null) {
                  chunk = '';
          } else if (Buffer.isBuffer(chunk)) {
                  if (!this.get('Content-Type')) {
                    this.type('bin');
            }
          } else {
                  return this.json(chunk);
          }
                break;
        }
        // write strings in utf-8
            if (typeof chunk === 'string') {
              encoding = 'utf8';
              type = this.get('Content-Type');

              // reflect this in content-type
              if (typeof type === 'string') {
                this.set('Content-Type', setCharset(type, 'utf-8'));
          }
        }
        // determine if ETag should be generated
            var etagFn = app.get('etag fn')
            var generateETag = !this.get('ETag') && typeof etagFn === 'function'

            // populate Content-Length
            var len
            if (chunk !== undefined) {
              if (Buffer.isBuffer(chunk)) {
            // get length of Buffer
                len = chunk.length
          } else if (!generateETag && chunk.length < 1000) {
            // just calculate length when no ETag + small chunk
                len = Buffer.byteLength(chunk, encoding)
          } else {
            // convert chunk to Buffer and calculate
                chunk = Buffer.from(chunk, encoding)
                encoding = undefined;
                len = chunk.length
          }

              this.set('Content-Length', len);
        }
        // populate ETag
            var etag;
            if (generateETag && len !== undefined) {
              if ((etag = etagFn(chunk, encoding))) {
                this.set('ETag', etag);
          }
        }
        // freshness
            if (req.fresh) this.statusCode = 304;

            // strip irrelevant headers
            if (204 === this.statusCode || 304 === this.statusCode) {
              this.removeHeader('Content-Type');
              this.removeHeader('Content-Length');
              this.removeHeader('Transfer-Encoding');
              chunk = '';
        }
        // alter headers for 205
            if (this.statusCode === 205) {
              this.set('Content-Length', '0')
              this.removeHeader('Transfer-Encoding')
              chunk = ''
        }

            if (req.method === 'HEAD') {
          // skip body for HEAD
              this.end();
        } else {
          // respond
              this.end(chunk, encoding);
        }

            return this;
      },
          send: (body) => {
            mcache.put(key, body, duration * 1000);
            res.sendResponse(body)
      },
    },
        _peername: {
          address: "::1",
            family: "IPv6",
              port: 56041,
    },
  },
        httpVersionMajor: 1,
          httpVersionMinor: 1,
            httpVersion: "1.1",
              complete: true,
                rawHeaders: [
    "Accept",
    "application/json, text/plain, */*",
    "User-Agent",
    "axios/0.24.0",
    "Host",
    "abounak.local:1394",
    "Connection",
    "close",
  ],
                  rawTrailers: [],
                    joinDuplicateHeaders: null,
                      aborted: false,
                        upgrade: false,
                          url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                            method: "GET",
                              statusCode: null,
                                statusMessage: null,
                                  client: {
          connecting: false,
            _hadError: false,
              _parent: null,
                _host: null,
                  _closeAfterHandlingError: false,
                    _readableState: {
            state: 4184,
              highWaterMark: 16384,
                buffer: {
              head: null,
                tail: null,
                  length: 0,
      },
            length: 0,
              pipes: [],
                flowing: true,
                  errored: null,
                    defaultEncoding: "utf8",
                      awaitDrainWriters: null,
                        decoder: null,
                          encoding: null,
    },
          _events: {
            end: [
              function onReadableStreamEnd() {
                if (!this.allowHalfOpen) {
                  this.write = writeAfterFIN;
          }
        },
              function () {
          [native code
          ]
        },
      ],
              timeout: function socketOnTimeout() {
                const req = this.parser && this.parser.incoming;
                const reqTimeout = req && !req.complete && req.emit('timeout', this);
                const res = this._httpMessage;
                const resTimeout = res && res.emit('timeout', this);
                const serverTimeout = this.server.emit('timeout', this);

                if (!reqTimeout && !resTimeout && !serverTimeout)
                  this.destroy();
      },
            data: function () {
        [native code
        ]
      },
            error: function socketOnError(e) {
        // Ignore further errors
              this.removeListener('error', socketOnError);

              if (this.listenerCount('error', noop) === 0) {
                this.on('error', noop);
        } else {
                warnUnclosedSocket();
        }

              if (!this.server.emit('clientError', e, this)) {
          // Caution must be taken to avoid corrupting the remote peer.
          // Reply an error segment if there is no in-flight `ServerResponse`,
          // or no data of the in-flight one has been written yet to this socket.
                if (this.writable &&
                  (!this._httpMessage || !this._httpMessage._headerSent)) {
                  let response;

                  switch (e.code) {
                    case 'HPE_HEADER_OVERFLOW':
                      response = requestHeaderFieldsTooLargeResponse;
                      break;
                    case 'HPE_CHUNK_EXTENSIONS_OVERFLOW':
                      response = requestChunkExtensionsTooLargeResponse;
                      break;
                    case 'ERR_HTTP_REQUEST_TIMEOUT':
                      response = requestTimeoutResponse;
                      break;
                    default:
                      response = badRequestResponse;
                      break;
            }

                  this.write(response);
          }
                this.destroy(e);
        }
      },
            close: [
              function () {
          [native code
          ]
        },
              function onServerResponseClose() {
          // EventEmitter.emit makes a copy of the 'close' listeners array before
          // calling the listeners. detachSocket() unregisters onServerResponseClose
          // but if detachSocket() is called, directly or indirectly, by a 'close'
          // listener, onServerResponseClose is still in that copy of the listeners
          // array. That is, in the example below, b still gets called even though
          // it's been removed by a:
          //
          //   const EventEmitter = require('events');
          //   const obj = new EventEmitter();
          //   obj.on('event', a);
          //   obj.on('event', b);
          //   function a() { obj.removeListener('event', b) }
          //   function b() { throw "BAM!" }
          //   obj.emit('event');  // throws
          //
          // Ergo, we need to deal with stale 'close' events and handle the case
          // where the ServerResponse object has already been deconstructed.
          // Fortunately, that requires only a single if check. :-)
                if (this._httpMessage) {
                  emitCloseNT(this._httpMessage);
          }
        },
      ],
              drain: function () {
        [native code
        ]
      },
            resume: function onSocketResume() {
        // It may seem that the socket is resumed, but this is an enemy's trick to
        // deceive us! `resume` is emitted asynchronously, and may be called from
        // `incoming.readStart()`. Stop the socket again here, just to preserve the
        // state.
        //
        // We don't care about stream semantics for the consumed socket anyway.
              if (this._paused) {
                this.pause();
                return;
        }

              if (this._handle && !this._handle.reading) {
                this._handle.reading = true;
                this._handle.readStart();
        }
      },
            pause: function onSocketPause() {
              if (this._handle && this._handle.reading) {
                this._handle.reading = false;
                this._handle.readStop();
        }
      },
    },
          _eventsCount: 8,
            _maxListeners: undefined,
              _writableState: {
            objectMode: false,
              highWaterMark: 16384,
                finalCalled: false,
                  needDrain: false,
                    ending: false,
                      ended: false,
                        finished: false,
                          destroyed: false,
                            decodeStrings: false,
                              defaultEncoding: "utf8",
                                length: 0,
                                  writing: false,
                                    corked: 0,
                                      sync: true,
                                        bufferProcessing: false,
                                          onwrite: function () {
        [native code
        ]
      },
            writecb: null,
              writelen: 0,
                afterWriteTickInfo: null,
                  buffered: [],
                    bufferedIndex: 0,
                      allBuffers: true,
                        allNoop: true,
                          pendingcb: 0,
                            constructed: true,
                              prefinished: false,
                                errorEmitted: false,
                                  emitClose: false,
                                    autoDestroy: true,
                                      errored: null,
                                        closed: false,
                                          closeEmitted: false,
    },
          allowHalfOpen: true,
            _sockname: null,
              _pendingData: null,
                _pendingEncoding: "",
                  server: {
            maxHeaderSize: undefined,
              insecureHTTPParser: undefined,
                requestTimeout: 300000,
                  headersTimeout: 60000,
                    keepAliveTimeout: 5000,
                      connectionsCheckingInterval: 30000,
                        joinDuplicateHeaders: undefined,
                          rejectNonStandardBodyWrites: false,
                            _events: {
              request: function(req, res, next) {
                app.handle(req, res, next);
        },
              connection: function connectionListener(socket) {
                defaultTriggerAsyncIdScope(
                  getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                );
        },
              listening: [
                function setupConnectionsTracking() {
            // Start connection handling
                  if (!this[kConnections
            ]) {
                    this[kConnections
              ] = new ConnectionsList();
            }
            // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
            // otherwise it would not be started if such timeouts are modified after createServer.
                  this[kConnectionsCheckingInterval
            ] =
                    setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
          },
                function () {
            [native code
            ]
          },
        ],
                error: function () {
          [native code
          ]
        },
              upgrade: (req, socket, head) => {
                this.handleUpgrade(req, socket, head, emitConnection);
        },
      },
            _eventsCount: 5,
              _maxListeners: undefined,
                _connections: 1,
                  _handle: {
              reading: false,
                onconnection: function onconnection(err, clientHandle) {
                  const handle = this;
                  const self = handle[owner_symbol
          ];

                  debug('onconnection');

                  if (err) {
                    self.emit('error', errnoException(err, 'accept'));
                    return;
          }

                  if (self.maxConnections && self._connections >= self.maxConnections) {
                    if (clientHandle.getsockname || clientHandle.getpeername) {
                      const data = ObjectCreate(null);
                      if (clientHandle.getsockname) {
                        const localInfo = ObjectCreate(null);
                        clientHandle.getsockname(localInfo);
                        data.localAddress = localInfo.address;
                        data.localPort = localInfo.port;
                        data.localFamily = localInfo.family;
              }
                      if (clientHandle.getpeername) {
                        const remoteInfo = ObjectCreate(null);
                        clientHandle.getpeername(remoteInfo);
                        data.remoteAddress = remoteInfo.address;
                        data.remotePort = remoteInfo.port;
                        data.remoteFamily = remoteInfo.family;
              }
                      self.emit('drop', data);
            } else {
                      self.emit('drop');
            }
                    clientHandle.close();
                    return;
          }

                  const socket = new Socket({
                    handle: clientHandle,
                    allowHalfOpen: self.allowHalfOpen,
                    pauseOnCreate: self.pauseOnConnect,
                    readable: true,
                    writable: true,
                    readableHighWaterMark: self.highWaterMark,
                    writableHighWaterMark: self.highWaterMark,
          });

                  if (self.noDelay && clientHandle.setNoDelay) {
                    socket[kSetNoDelay
            ] = true;
                    clientHandle.setNoDelay(true);
          }
                  if (self.keepAlive && clientHandle.setKeepAlive) {
                    socket[kSetKeepAlive
            ] = true;
                    socket[kSetKeepAliveInitialDelay
            ] = self.keepAliveInitialDelay;
                    clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
          }

                  self._connections++;
                  socket.server = self;
                  socket._server = self;

                  DTRACE_NET_SERVER_CONNECTION(socket);
                  self.emit('connection', socket);
                  lazyChannels();
                  if (netServerSocketChannel.hasSubscribers) {
                    netServerSocketChannel.publish({
                      socket,
            });
          }
        },
      },
            _usingWorkers: false,
              _workers: [],
                _unref: false,
                  allowHalfOpen: true,
                    pauseOnConnect: false,
                      noDelay: true,
                        keepAlive: false,
                          keepAliveInitialDelay: 0,
                            highWaterMark: 16384,
                              httpAllowHalfOpen: false,
                                timeout: 0,
                                  maxHeadersCount: null,
                                    maxRequestsPerSocket: 0,
                                      _connectionKey: "6::::1394",
    },
          _server: {
            maxHeaderSize: undefined,
              insecureHTTPParser: undefined,
                requestTimeout: 300000,
                  headersTimeout: 60000,
                    keepAliveTimeout: 5000,
                      connectionsCheckingInterval: 30000,
                        joinDuplicateHeaders: undefined,
                          rejectNonStandardBodyWrites: false,
                            _events: {
              request: function(req, res, next) {
                app.handle(req, res, next);
        },
              connection: function connectionListener(socket) {
                defaultTriggerAsyncIdScope(
                  getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                );
        },
              listening: [
                function setupConnectionsTracking() {
            // Start connection handling
                  if (!this[kConnections
            ]) {
                    this[kConnections
              ] = new ConnectionsList();
            }
            // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
            // otherwise it would not be started if such timeouts are modified after createServer.
                  this[kConnectionsCheckingInterval
            ] =
                    setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
          },
                function () {
            [native code
            ]
          },
        ],
                error: function () {
          [native code
          ]
        },
              upgrade: (req, socket, head) => {
                this.handleUpgrade(req, socket, head, emitConnection);
        },
      },
            _eventsCount: 5,
              _maxListeners: undefined,
                _connections: 1,
                  _handle: {
              reading: false,
                onconnection: function onconnection(err, clientHandle) {
                  const handle = this;
                  const self = handle[owner_symbol
          ];

                  debug('onconnection');

                  if (err) {
                    self.emit('error', errnoException(err, 'accept'));
                    return;
          }

                  if (self.maxConnections && self._connections >= self.maxConnections) {
                    if (clientHandle.getsockname || clientHandle.getpeername) {
                      const data = ObjectCreate(null);
                      if (clientHandle.getsockname) {
                        const localInfo = ObjectCreate(null);
                        clientHandle.getsockname(localInfo);
                        data.localAddress = localInfo.address;
                        data.localPort = localInfo.port;
                        data.localFamily = localInfo.family;
              }
                      if (clientHandle.getpeername) {
                        const remoteInfo = ObjectCreate(null);
                        clientHandle.getpeername(remoteInfo);
                        data.remoteAddress = remoteInfo.address;
                        data.remotePort = remoteInfo.port;
                        data.remoteFamily = remoteInfo.family;
              }
                      self.emit('drop', data);
            } else {
                      self.emit('drop');
            }
                    clientHandle.close();
                    return;
          }

                  const socket = new Socket({
                    handle: clientHandle,
                    allowHalfOpen: self.allowHalfOpen,
                    pauseOnCreate: self.pauseOnConnect,
                    readable: true,
                    writable: true,
                    readableHighWaterMark: self.highWaterMark,
                    writableHighWaterMark: self.highWaterMark,
          });

                  if (self.noDelay && clientHandle.setNoDelay) {
                    socket[kSetNoDelay
            ] = true;
                    clientHandle.setNoDelay(true);
          }
                  if (self.keepAlive && clientHandle.setKeepAlive) {
                    socket[kSetKeepAlive
            ] = true;
                    socket[kSetKeepAliveInitialDelay
            ] = self.keepAliveInitialDelay;
                    clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
          }

                  self._connections++;
                  socket.server = self;
                  socket._server = self;

                  DTRACE_NET_SERVER_CONNECTION(socket);
                  self.emit('connection', socket);
                  lazyChannels();
                  if (netServerSocketChannel.hasSubscribers) {
                    netServerSocketChannel.publish({
                      socket,
            });
          }
        },
      },
            _usingWorkers: false,
              _workers: [],
                _unref: false,
                  allowHalfOpen: true,
                    pauseOnConnect: false,
                      noDelay: true,
                        keepAlive: false,
                          keepAliveInitialDelay: 0,
                            highWaterMark: 16384,
                              httpAllowHalfOpen: false,
                                timeout: 0,
                                  maxHeadersCount: null,
                                    maxRequestsPerSocket: 0,
                                      _connectionKey: "6::::1394",
    },
          parser: {
      "0": null,
      "1": function parserOnHeaders(headers, url) {
        // Once we exceeded headers limit - stop collecting them
                if (this.maxHeaderPairs <= 0 ||
                  this._headers.length < this.maxHeaderPairs) {
                  this._headers.push(...headers);
        }
                this._url += url;
      },
      "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
              url, statusCode, statusMessage, upgrade,
              shouldKeepAlive) {
              const parser = this;
              const { socket
        } = parser;

              if (headers === undefined) {
                headers = parser._headers;
                parser._headers = [];
        }

              if (url === undefined) {
                url = parser._url;
                parser._url = '';
        }
        // Parser is also used by http client
              const ParserIncomingMessage = (socket && socket.server &&
                socket.server[kIncomingMessage
        ]) ||
                IncomingMessage;

              const incoming = parser.incoming = new ParserIncomingMessage(socket);
              incoming.httpVersionMajor = versionMajor;
              incoming.httpVersionMinor = versionMinor;
              incoming.httpVersion = `${versionMajor
        }.${versionMinor
        }`;
              incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
                parser.joinDuplicateHeaders;
              incoming.url = url;
              incoming.upgrade = upgrade;

              let n = headers.length;

              // If parser.maxHeaderPairs <= 0 assume that there's no limit.
              if (parser.maxHeaderPairs > 0)
                n = MathMin(n, parser.maxHeaderPairs);

              incoming._addHeaderLines(headers, n);

              if (typeof method === 'number') {
          // server only
                incoming.method = methods[method
          ];
        } else {
          // client only
                incoming.statusCode = statusCode;
                incoming.statusMessage = statusMessage;
        }

              return parser.onIncoming(incoming, shouldKeepAlive);
      },
      "3": function parserOnBody(b) {
              const stream = this.incoming;

              // If the stream has already been removed, then drop it.
              if (stream === null)
                return;

              // Pretend this was the result of a stream._read call.
              if (!stream._dumped) {
                const ret = stream.push(b);
                if (!ret)
                  readStop(this.socket);
        }
      },
      "4": function parserOnMessageComplete() {
              const parser = this;
              const stream = parser.incoming;

              if (stream !== null) {
                stream.complete = true;
                // Emit any trailing headers.
                const headers = parser._headers;
                if (headers.length) {
                  stream._addHeaderLines(headers, headers.length);
                  parser._headers = [];
                  parser._url = '';
          }
          // For emit end event
                stream.push(null);
        }
        // Force to read the next incoming message
              readStart(parser.socket);
      },
      "5": function () {
        [native code
        ]
      },
      "6": function () {
        [native code
        ]
      },
            _headers: [],
              _url: "",
                socket: [Circular
      ],
                  incoming: {
              _readableState: {
                state: 137266,
                  highWaterMark: 16384,
                    buffer: {
                  head: null,
                    tail: null,
                      length: 0,
          },
                length: 0,
                  pipes: [],
                    flowing: null,
                      errored: null,
                        defaultEncoding: "utf8",
                          awaitDrainWriters: null,
                            decoder: null,
                              encoding: null,
        },
              _events: {},
              _eventsCount: 0,
                _maxListeners: undefined,
                  socket: [Circular
        ],
                    httpVersionMajor: 1,
                      httpVersionMinor: 1,
                        httpVersion: "1.1",
                          complete: true,
                            rawHeaders: [
          "Accept",
          "application/json, text/plain, */*",
          "User-Agent",
          "axios/0.24.0",
          "Host",
          "abounak.local:1394",
          "Connection",
          "close",
        ],
                              rawTrailers: [],
                                joinDuplicateHeaders: null,
                                  aborted: false,
                                    upgrade: false,
                                      url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                        method: "GET",
                                          statusCode: null,
                                            statusMessage: null,
                                              client: [Circular
        ],
                                                _consuming: false,
                                                  _dumped: false,
                                                    next: function next(err) {
                                                      var layerError = err === 'route'
                                                        ? null
                                                        : err;

                                                      // remove added slash
                                                      if (slashAdded) {
                                                        req.url = req.url.slice(1)
                                                        slashAdded = false;
          }
          // restore altered req.url
                                                      if (removed.length !== 0) {
                                                        req.baseUrl = parentUrl;
                                                        req.url = protohost + removed + req.url.slice(protohost.length)
                                                        removed = '';
          }
          // signal to exit router
                                                      if (layerError === 'router') {
                                                        setImmediate(done, null)
                                                        return
          }
          // no more matching layers
                                                      if (idx >= stack.length) {
                                                        setImmediate(done, layerError);
                                                        return;
          }
          // max sync stack
                                                      if (++sync > 100) {
                                                        return setImmediate(next, err)
          }
          // get pathname of request
                                                      var path = getPathname(req);

                                                      if (path == null) {
                                                        return done(layerError);
          }
          // find next matching layer
                                                      var layer;
                                                      var match;
                                                      var route;

                                                      while (match !== true && idx < stack.length) {
                                                        layer = stack[idx++
            ];
                                                        match = matchLayer(layer, path);
                                                        route = layer.route;

                                                        if (typeof match !== 'boolean') {
              // hold on to layerError
                                                          layerError = layerError || match;
            }

                                                        if (match !== true) {
                                                          continue;
            }

                                                        if (!route) {
              // process non-route handlers normally
                                                          continue;
            }

                                                        if (layerError) {
              // routes do not match with a pending error
                                                          match = false;
                                                          continue;
            }

                                                        var method = req.method;
                                                        var has_method = route._handles_method(method);

                                                        // build up automatic options response
                                                        if (!has_method && method === 'OPTIONS') {
                                                          appendMethods(options, route._options());
            }
            // don't even bother matching route
                                                        if (!has_method && method !== 'HEAD') {
                                                          match = false;
            }
          }
          // no match
                                                      if (match !== true) {
                                                        return done(layerError);
          }
          // store route for dispatch on change
                                                      if (route) {
                                                        req.route = route;
          }
          // Capture one-time layer values
                                                      req.params = self.mergeParams
                                                        ? mergeParams(layer.params, parentParams)
                                                        : layer.params;
                                                      var layerPath = layer.path;

                                                      // this should be done for the layer
                                                      self.process_params(layer, paramcalled, req, res, function (err) {
                                                        if (err) {
                                                          next(layerError || err)
            } else if (route) {
                                                          layer.handle_request(req, res, next)
            } else {
                                                          trim_prefix(layer, layerError, layerPath, path)
            }

                                                        sync = 0
          });
        },
              baseUrl: "",
                originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                  _parsedUrl: {
                protocol: null,
                  slashes: null,
                    auth: null,
                      host: null,
                        port: null,
                          hostname: null,
                            hash: null,
                              search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                  pathname: "/parseUserMe",
                                    path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                      href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                        _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
        },
              params: {},
              query: {
                usersession: "r:255111ff859d0977bb5b94ce2782d69d",
                  include: "entity",
        },
              res: {
                _events: {
                  finish: function () {
              [native code
              ]
            },
          },
                _eventsCount: 1,
                  _maxListeners: undefined,
                    outputData: [],
                      outputSize: 0,
                        writable: true,
                          destroyed: false,
                            _last: false,
                              chunkedEncoding: false,
                                shouldKeepAlive: false,
                                  maxRequestsOnConnectionReached: false,
                                    _defaultKeepAlive: true,
                                      useChunkedEncodingByDefault: true,
                                        sendDate: true,
                                          _removedConnection: false,
                                            _removedContLen: false,
                                              _removedTE: false,
                                                strictContentLength: false,
                                                  _contentLength: null,
                                                    _hasBody: true,
                                                      _trailer: "",
                                                        finished: false,
                                                          _headerSent: false,
                                                            _closed: false,
                                                              socket: [Circular
          ],
                                                                _header: null,
                                                                  _keepAliveTimeout: 5000,
                                                                    _onPendingData: function () {
            [native code
            ]
          },
                req: [Circular
          ],
                  _sent100: false,
                    _expect_continue: false,
                      _maxRequestsPerSocket: 0,
                        locals: {},
                flush: function flush() {
                  if (stream) {
                    stream.flush()
            }
          },
                write: function write(chunk, encoding) {
                  if (ended) {
                    return false
            }

                  if (!this._header) {
                    this._implicitHeader()
            }

                  return stream
                    ? stream.write(toBuffer(chunk, encoding))
                    : _write.call(this, chunk, encoding)
          },
                end: function end(chunk, encoding) {
                  if (ended) {
                    return false
            }

                  if (!this._header) {
              // estimate the length
                    if (!this.getHeader('Content-Length')) {
                      length = chunkLength(chunk, encoding)
              }

                    this._implicitHeader()
            }

                  if (!stream) {
                    return _end.call(this, chunk, encoding)
            }
            // mark ended
                  ended = true
            // write Buffer for Node.js 0.8
                  return chunk
                    ? stream.end(toBuffer(chunk, encoding))
                    : stream.end()
          },
                on: function on(type, listener) {
                  if (!listeners || type !== 'drain') {
                    return _on.call(this, type, listener)
            }

                  if (stream) {
                    return stream.on(type, listener)
            }
            // buffer listeners for future stream
                  listeners.push([type, listener
            ])

                  return this
          },
                writeHead: function writeHead(statusCode) {
            // set headers from arguments
                  var args = setWriteHeadHeaders.apply(this, arguments)

                  // fire listener
                  if (!fired) {
                    fired = true
                    listener.call(this)

                    // pass-along an updated status code
                    if (typeof args[
                0
              ] === 'number' && this.statusCode !== args[
                0
              ]) {
                      args[
                  0
                ] = this.statusCode
                      args.length = 1
              }
            }

                  return prevWriteHead.apply(this, args)
          },
                sendResponse: function send(body) {
                  var chunk = body;
                  var encoding;
                  var req = this.req;
                  var type;

                  // settings
                  var app = this.app;

                  // allow status / body
                  if (arguments.length === 2) {
              // res.send(body, status) backwards compat
                    if (typeof arguments[
                0
              ] !== 'number' && typeof arguments[
                1
              ] === 'number') {
                      deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                      this.statusCode = arguments[
                  1
                ];
              } else {
                      deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                      this.statusCode = arguments[
                  0
                ];
                      chunk = arguments[
                  1
                ];
              }
            }
            // disambiguate res.send(status) and res.send(status, num)
                  if (typeof chunk === 'number' && arguments.length === 1) {
              // res.send(status) will set status message as text string
                    if (!this.get('Content-Type')) {
                      this.type('txt');
              }

                    deprecate('res.send(status): Use res.sendStatus(status) instead');
                    this.statusCode = chunk;
                    chunk = statuses.message[chunk
              ]
            }

                  switch (typeof chunk) {
              // string defaulting to html
                    case 'string':
                      if (!this.get('Content-Type')) {
                        this.type('html');
              }
                      break;
                    case 'boolean':
                    case 'number':
                    case 'object':
                      if (chunk === null) {
                        chunk = '';
              } else if (Buffer.isBuffer(chunk)) {
                        if (!this.get('Content-Type')) {
                          this.type('bin');
                }
              } else {
                        return this.json(chunk);
              }
                      break;
            }
            // write strings in utf-8
                  if (typeof chunk === 'string') {
                    encoding = 'utf8';
                    type = this.get('Content-Type');

                    // reflect this in content-type
                    if (typeof type === 'string') {
                      this.set('Content-Type', setCharset(type, 'utf-8'));
              }
            }
            // determine if ETag should be generated
                  var etagFn = app.get('etag fn')
                  var generateETag = !this.get('ETag') && typeof etagFn === 'function'

                  // populate Content-Length
                  var len
                  if (chunk !== undefined) {
                    if (Buffer.isBuffer(chunk)) {
                // get length of Buffer
                      len = chunk.length
              } else if (!generateETag && chunk.length < 1000) {
                // just calculate length when no ETag + small chunk
                      len = Buffer.byteLength(chunk, encoding)
              } else {
                // convert chunk to Buffer and calculate
                      chunk = Buffer.from(chunk, encoding)
                      encoding = undefined;
                      len = chunk.length
              }

                    this.set('Content-Length', len);
            }
            // populate ETag
                  var etag;
                  if (generateETag && len !== undefined) {
                    if ((etag = etagFn(chunk, encoding))) {
                      this.set('ETag', etag);
              }
            }
            // freshness
                  if (req.fresh) this.statusCode = 304;

                  // strip irrelevant headers
                  if (204 === this.statusCode || 304 === this.statusCode) {
                    this.removeHeader('Content-Type');
                    this.removeHeader('Content-Length');
                    this.removeHeader('Transfer-Encoding');
                    chunk = '';
            }
            // alter headers for 205
                  if (this.statusCode === 205) {
                    this.set('Content-Length', '0')
                    this.removeHeader('Transfer-Encoding')
                    chunk = ''
            }

                  if (req.method === 'HEAD') {
              // skip body for HEAD
                    this.end();
            } else {
              // respond
                    this.end(chunk, encoding);
            }

                  return this;
          },
                send: (body) => {
                  mcache.put(key, body, duration * 1000);
                  res.sendResponse(body)
          },
        },
              body: {},
              route: {
                path: "/parseuserme",
                  stack: [
            {
                      handle: (req, res, next) => {
                        let key = '__express__' + req.originalUrl || req.url
                        let cachedBody = mcache.get(key)
                        if (cachedBody) {
                          res.send(cachedBody)
                          return
                } else {
                          res.sendResponse = res.send
                          res.send = (body) => {
                            mcache.put(key, body, duration * 1000);
                            res.sendResponse(body)
                  }
                          next()
                }
              },
                      name: "<anonymous>",
                      params: undefined,
                      path: undefined,
                      keys: [],
                      regexp: {
                        fast_star: false,
                        fast_slash: false,
              },
                      method: "get",
            },
            {
                      handle: async (request, response, next) => {
                        try {
                          await Promise.resolve(fn(request, response, next)).catch(next);
                } catch (error) {
                          next(error);
                }
              },
                      name: "<anonymous>",
                      params: undefined,
                      path: undefined,
                      keys: [],
                      regexp: {
                        fast_star: false,
                        fast_slash: false,
              },
                      method: "get",
            },
            {
                      handle: async (request, response, next) => {
                        await doHandle({ handler, request, response, next
                })
              },
                      name: "<anonymous>",
                      params: undefined,
                      path: undefined,
                      keys: [],
                      regexp: {
                        fast_star: false,
                        fast_slash: false,
              },
                      method: "get",
            },
          ],
                    methods: {
                  get: true,
          },
        },
              rateLimit: {
                limit: 1000,
                  used: 1,
                    remaining: 999,
                      resetTime: "2024-07-19T11:30:07.125Z",
        },
      },
            outgoing: null,
              maxHeaderPairs: 2000,
                _consumed: true,
                  onIncoming: function () {
        [native code
        ]
      },
            joinDuplicateHeaders: null,
    },
          on: function socketListenerWrap(ev, fn) {
            const res = net.Socket.prototype[originalFnName
      ].call(this,
              ev, fn);
            if (!this.parser) {
              this.on = net.Socket.prototype.on;
              this.addListener = net.Socket.prototype.addListener;
              this.prependListener = net.Socket.prototype.prependListener;
              return res;
      }

            if (ev === 'data' || ev === 'readable')
              unconsume(this.parser, this);

            return res;
    },
          addListener: function socketListenerWrap(ev, fn) {
            const res = net.Socket.prototype[originalFnName
      ].call(this,
              ev, fn);
            if (!this.parser) {
              this.on = net.Socket.prototype.on;
              this.addListener = net.Socket.prototype.addListener;
              this.prependListener = net.Socket.prototype.prependListener;
              return res;
      }

            if (ev === 'data' || ev === 'readable')
              unconsume(this.parser, this);

            return res;
    },
          prependListener: function socketListenerWrap(ev, fn) {
            const res = net.Socket.prototype[originalFnName
      ].call(this,
              ev, fn);
            if (!this.parser) {
              this.on = net.Socket.prototype.on;
              this.addListener = net.Socket.prototype.addListener;
              this.prependListener = net.Socket.prototype.prependListener;
              return res;
      }

            if (ev === 'data' || ev === 'readable')
              unconsume(this.parser, this);

            return res;
    },
          setEncoding: function socketSetEncoding() {
            throw new ERR_HTTP_SOCKET_ENCODING();
    },
          _paused: false,
            _httpMessage: {
            _events: {
              finish: function () {
          [native code
          ]
        },
      },
            _eventsCount: 1,
              _maxListeners: undefined,
                outputData: [],
                  outputSize: 0,
                    writable: true,
                      destroyed: false,
                        _last: false,
                          chunkedEncoding: false,
                            shouldKeepAlive: false,
                              maxRequestsOnConnectionReached: false,
                                _defaultKeepAlive: true,
                                  useChunkedEncodingByDefault: true,
                                    sendDate: true,
                                      _removedConnection: false,
                                        _removedContLen: false,
                                          _removedTE: false,
                                            strictContentLength: false,
                                              _contentLength: null,
                                                _hasBody: true,
                                                  _trailer: "",
                                                    finished: false,
                                                      _headerSent: false,
                                                        _closed: false,
                                                          socket: [Circular
      ],
                                                            _header: null,
                                                              _keepAliveTimeout: 5000,
                                                                _onPendingData: function () {
        [native code
        ]
      },
            req: {
              _readableState: {
                state: 137266,
                  highWaterMark: 16384,
                    buffer: {
                  head: null,
                    tail: null,
                      length: 0,
          },
                length: 0,
                  pipes: [],
                    flowing: null,
                      errored: null,
                        defaultEncoding: "utf8",
                          awaitDrainWriters: null,
                            decoder: null,
                              encoding: null,
        },
              _events: {},
              _eventsCount: 0,
                _maxListeners: undefined,
                  socket: [Circular
        ],
                    httpVersionMajor: 1,
                      httpVersionMinor: 1,
                        httpVersion: "1.1",
                          complete: true,
                            rawHeaders: [
          "Accept",
          "application/json, text/plain, */*",
          "User-Agent",
          "axios/0.24.0",
          "Host",
          "abounak.local:1394",
          "Connection",
          "close",
        ],
                              rawTrailers: [],
                                joinDuplicateHeaders: null,
                                  aborted: false,
                                    upgrade: false,
                                      url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                        method: "GET",
                                          statusCode: null,
                                            statusMessage: null,
                                              client: [Circular
        ],
                                                _consuming: false,
                                                  _dumped: false,
                                                    next: function next(err) {
                                                      var layerError = err === 'route'
                                                        ? null
                                                        : err;

                                                      // remove added slash
                                                      if (slashAdded) {
                                                        req.url = req.url.slice(1)
                                                        slashAdded = false;
          }
          // restore altered req.url
                                                      if (removed.length !== 0) {
                                                        req.baseUrl = parentUrl;
                                                        req.url = protohost + removed + req.url.slice(protohost.length)
                                                        removed = '';
          }
          // signal to exit router
                                                      if (layerError === 'router') {
                                                        setImmediate(done, null)
                                                        return
          }
          // no more matching layers
                                                      if (idx >= stack.length) {
                                                        setImmediate(done, layerError);
                                                        return;
          }
          // max sync stack
                                                      if (++sync > 100) {
                                                        return setImmediate(next, err)
          }
          // get pathname of request
                                                      var path = getPathname(req);

                                                      if (path == null) {
                                                        return done(layerError);
          }
          // find next matching layer
                                                      var layer;
                                                      var match;
                                                      var route;

                                                      while (match !== true && idx < stack.length) {
                                                        layer = stack[idx++
            ];
                                                        match = matchLayer(layer, path);
                                                        route = layer.route;

                                                        if (typeof match !== 'boolean') {
              // hold on to layerError
                                                          layerError = layerError || match;
            }

                                                        if (match !== true) {
                                                          continue;
            }

                                                        if (!route) {
              // process non-route handlers normally
                                                          continue;
            }

                                                        if (layerError) {
              // routes do not match with a pending error
                                                          match = false;
                                                          continue;
            }

                                                        var method = req.method;
                                                        var has_method = route._handles_method(method);

                                                        // build up automatic options response
                                                        if (!has_method && method === 'OPTIONS') {
                                                          appendMethods(options, route._options());
            }
            // don't even bother matching route
                                                        if (!has_method && method !== 'HEAD') {
                                                          match = false;
            }
          }
          // no match
                                                      if (match !== true) {
                                                        return done(layerError);
          }
          // store route for dispatch on change
                                                      if (route) {
                                                        req.route = route;
          }
          // Capture one-time layer values
                                                      req.params = self.mergeParams
                                                        ? mergeParams(layer.params, parentParams)
                                                        : layer.params;
                                                      var layerPath = layer.path;

                                                      // this should be done for the layer
                                                      self.process_params(layer, paramcalled, req, res, function (err) {
                                                        if (err) {
                                                          next(layerError || err)
            } else if (route) {
                                                          layer.handle_request(req, res, next)
            } else {
                                                          trim_prefix(layer, layerError, layerPath, path)
            }

                                                        sync = 0
          });
        },
              baseUrl: "",
                originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                  _parsedUrl: {
                protocol: null,
                  slashes: null,
                    auth: null,
                      host: null,
                        port: null,
                          hostname: null,
                            hash: null,
                              search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                  pathname: "/parseUserMe",
                                    path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                      href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                        _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
        },
              params: {},
              query: {
                usersession: "r:255111ff859d0977bb5b94ce2782d69d",
                  include: "entity",
        },
              res: [Circular
        ],
                body: {},
              route: {
                path: "/parseuserme",
                  stack: [
            {
                      handle: (req, res, next) => {
                        let key = '__express__' + req.originalUrl || req.url
                        let cachedBody = mcache.get(key)
                        if (cachedBody) {
                          res.send(cachedBody)
                          return
                } else {
                          res.sendResponse = res.send
                          res.send = (body) => {
                            mcache.put(key, body, duration * 1000);
                            res.sendResponse(body)
                  }
                          next()
                }
              },
                      name: "<anonymous>",
                      params: undefined,
                      path: undefined,
                      keys: [],
                      regexp: {
                        fast_star: false,
                        fast_slash: false,
              },
                      method: "get",
            },
            {
                      handle: async (request, response, next) => {
                        try {
                          await Promise.resolve(fn(request, response, next)).catch(next);
                } catch (error) {
                          next(error);
                }
              },
                      name: "<anonymous>",
                      params: undefined,
                      path: undefined,
                      keys: [],
                      regexp: {
                        fast_star: false,
                        fast_slash: false,
              },
                      method: "get",
            },
            {
                      handle: async (request, response, next) => {
                        await doHandle({ handler, request, response, next
                })
              },
                      name: "<anonymous>",
                      params: undefined,
                      path: undefined,
                      keys: [],
                      regexp: {
                        fast_star: false,
                        fast_slash: false,
              },
                      method: "get",
            },
          ],
                    methods: {
                  get: true,
          },
        },
              rateLimit: {
                limit: 1000,
                  used: 1,
                    remaining: 999,
                      resetTime: "2024-07-19T11:30:07.125Z",
        },
      },
            _sent100: false,
              _expect_continue: false,
                _maxRequestsPerSocket: 0,
                  locals: {},
            flush: function flush() {
              if (stream) {
                stream.flush()
        }
      },
            write: function write(chunk, encoding) {
              if (ended) {
                return false
        }

              if (!this._header) {
                this._implicitHeader()
        }

              return stream
                ? stream.write(toBuffer(chunk, encoding))
                : _write.call(this, chunk, encoding)
      },
            end: function end(chunk, encoding) {
              if (ended) {
                return false
        }

              if (!this._header) {
          // estimate the length
                if (!this.getHeader('Content-Length')) {
                  length = chunkLength(chunk, encoding)
          }

                this._implicitHeader()
        }

              if (!stream) {
                return _end.call(this, chunk, encoding)
        }
        // mark ended
              ended = true
        // write Buffer for Node.js 0.8
              return chunk
                ? stream.end(toBuffer(chunk, encoding))
                : stream.end()
      },
            on: function on(type, listener) {
              if (!listeners || type !== 'drain') {
                return _on.call(this, type, listener)
        }

              if (stream) {
                return stream.on(type, listener)
        }
        // buffer listeners for future stream
              listeners.push([type, listener
        ])

              return this
      },
            writeHead: function writeHead(statusCode) {
        // set headers from arguments
              var args = setWriteHeadHeaders.apply(this, arguments)

              // fire listener
              if (!fired) {
                fired = true
                listener.call(this)

                // pass-along an updated status code
                if (typeof args[
            0
          ] === 'number' && this.statusCode !== args[
            0
          ]) {
                  args[
              0
            ] = this.statusCode
                  args.length = 1
          }
        }

              return prevWriteHead.apply(this, args)
      },
            sendResponse: function send(body) {
              var chunk = body;
              var encoding;
              var req = this.req;
              var type;

              // settings
              var app = this.app;

              // allow status / body
              if (arguments.length === 2) {
          // res.send(body, status) backwards compat
                if (typeof arguments[
            0
          ] !== 'number' && typeof arguments[
            1
          ] === 'number') {
                  deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                  this.statusCode = arguments[
              1
            ];
          } else {
                  deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                  this.statusCode = arguments[
              0
            ];
                  chunk = arguments[
              1
            ];
          }
        }
        // disambiguate res.send(status) and res.send(status, num)
              if (typeof chunk === 'number' && arguments.length === 1) {
          // res.send(status) will set status message as text string
                if (!this.get('Content-Type')) {
                  this.type('txt');
          }

                deprecate('res.send(status): Use res.sendStatus(status) instead');
                this.statusCode = chunk;
                chunk = statuses.message[chunk
          ]
        }

              switch (typeof chunk) {
          // string defaulting to html
                case 'string':
                  if (!this.get('Content-Type')) {
                    this.type('html');
          }
                  break;
                case 'boolean':
                case 'number':
                case 'object':
                  if (chunk === null) {
                    chunk = '';
          } else if (Buffer.isBuffer(chunk)) {
                    if (!this.get('Content-Type')) {
                      this.type('bin');
            }
          } else {
                    return this.json(chunk);
          }
                  break;
        }
        // write strings in utf-8
              if (typeof chunk === 'string') {
                encoding = 'utf8';
                type = this.get('Content-Type');

                // reflect this in content-type
                if (typeof type === 'string') {
                  this.set('Content-Type', setCharset(type, 'utf-8'));
          }
        }
        // determine if ETag should be generated
              var etagFn = app.get('etag fn')
              var generateETag = !this.get('ETag') && typeof etagFn === 'function'

              // populate Content-Length
              var len
              if (chunk !== undefined) {
                if (Buffer.isBuffer(chunk)) {
            // get length of Buffer
                  len = chunk.length
          } else if (!generateETag && chunk.length < 1000) {
            // just calculate length when no ETag + small chunk
                  len = Buffer.byteLength(chunk, encoding)
          } else {
            // convert chunk to Buffer and calculate
                  chunk = Buffer.from(chunk, encoding)
                  encoding = undefined;
                  len = chunk.length
          }

                this.set('Content-Length', len);
        }
        // populate ETag
              var etag;
              if (generateETag && len !== undefined) {
                if ((etag = etagFn(chunk, encoding))) {
                  this.set('ETag', etag);
          }
        }
        // freshness
              if (req.fresh) this.statusCode = 304;

              // strip irrelevant headers
              if (204 === this.statusCode || 304 === this.statusCode) {
                this.removeHeader('Content-Type');
                this.removeHeader('Content-Length');
                this.removeHeader('Transfer-Encoding');
                chunk = '';
        }
        // alter headers for 205
              if (this.statusCode === 205) {
                this.set('Content-Length', '0')
                this.removeHeader('Transfer-Encoding')
                chunk = ''
        }

              if (req.method === 'HEAD') {
          // skip body for HEAD
                this.end();
        } else {
          // respond
                this.end(chunk, encoding);
        }

              return this;
      },
            send: (body) => {
              mcache.put(key, body, duration * 1000);
              res.sendResponse(body)
      },
    },
          _peername: {
            address: "::1",
              family: "IPv6",
                port: 56041,
    },
  },
        _consuming: false,
          _dumped: false,
            next: function next(err) {
              var layerError = err === 'route'
                ? null
                : err;

              // remove added slash
              if (slashAdded) {
                req.url = req.url.slice(1)
                slashAdded = false;
    }
    // restore altered req.url
              if (removed.length !== 0) {
                req.baseUrl = parentUrl;
                req.url = protohost + removed + req.url.slice(protohost.length)
                removed = '';
    }
    // signal to exit router
              if (layerError === 'router') {
                setImmediate(done, null)
                return
    }
    // no more matching layers
              if (idx >= stack.length) {
                setImmediate(done, layerError);
                return;
    }
    // max sync stack
              if (++sync > 100) {
                return setImmediate(next, err)
    }
    // get pathname of request
              var path = getPathname(req);

              if (path == null) {
                return done(layerError);
    }
    // find next matching layer
              var layer;
              var match;
              var route;

              while (match !== true && idx < stack.length) {
                layer = stack[idx++
      ];
                match = matchLayer(layer, path);
                route = layer.route;

                if (typeof match !== 'boolean') {
        // hold on to layerError
                  layerError = layerError || match;
      }

                if (match !== true) {
                  continue;
      }

                if (!route) {
        // process non-route handlers normally
                  continue;
      }

                if (layerError) {
        // routes do not match with a pending error
                  match = false;
                  continue;
      }

                var method = req.method;
                var has_method = route._handles_method(method);

                // build up automatic options response
                if (!has_method && method === 'OPTIONS') {
                  appendMethods(options, route._options());
      }
      // don't even bother matching route
                if (!has_method && method !== 'HEAD') {
                  match = false;
      }
    }
    // no match
              if (match !== true) {
                return done(layerError);
    }
    // store route for dispatch on change
              if (route) {
                req.route = route;
    }
    // Capture one-time layer values
              req.params = self.mergeParams
                ? mergeParams(layer.params, parentParams)
                : layer.params;
              var layerPath = layer.path;

              // this should be done for the layer
              self.process_params(layer, paramcalled, req, res, function (err) {
                if (err) {
                  next(layerError || err)
      } else if (route) {
                  layer.handle_request(req, res, next)
      } else {
                  trim_prefix(layer, layerError, layerPath, path)
      }

                sync = 0
    });
  },
        baseUrl: "",
          originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
            _parsedUrl: {
          protocol: null,
            slashes: null,
              auth: null,
                host: null,
                  port: null,
                    hostname: null,
                      hash: null,
                        search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                          query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                            pathname: "/parseUserMe",
                              path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                  _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
  },
        params: {},
        query: {
          usersession: "r:255111ff859d0977bb5b94ce2782d69d",
            include: "entity",
  },
        res: {
          _events: {
            finish: function () {
        [native code
        ]
      },
    },
          _eventsCount: 1,
            _maxListeners: undefined,
              outputData: [],
                outputSize: 0,
                  writable: true,
                    destroyed: false,
                      _last: false,
                        chunkedEncoding: false,
                          shouldKeepAlive: false,
                            maxRequestsOnConnectionReached: false,
                              _defaultKeepAlive: true,
                                useChunkedEncodingByDefault: true,
                                  sendDate: true,
                                    _removedConnection: false,
                                      _removedContLen: false,
                                        _removedTE: false,
                                          strictContentLength: false,
                                            _contentLength: null,
                                              _hasBody: true,
                                                _trailer: "",
                                                  finished: false,
                                                    _headerSent: false,
                                                      _closed: false,
                                                        socket: {
            connecting: false,
              _hadError: false,
                _parent: null,
                  _host: null,
                    _closeAfterHandlingError: false,
                      _readableState: {
              state: 4184,
                highWaterMark: 16384,
                  buffer: {
                head: null,
                  tail: null,
                    length: 0,
        },
              length: 0,
                pipes: [],
                  flowing: true,
                    errored: null,
                      defaultEncoding: "utf8",
                        awaitDrainWriters: null,
                          decoder: null,
                            encoding: null,
      },
            _events: {
              end: [
                function onReadableStreamEnd() {
                  if (!this.allowHalfOpen) {
                    this.write = writeAfterFIN;
            }
          },
                function () {
            [native code
            ]
          },
        ],
                timeout: function socketOnTimeout() {
                  const req = this.parser && this.parser.incoming;
                  const reqTimeout = req && !req.complete && req.emit('timeout', this);
                  const res = this._httpMessage;
                  const resTimeout = res && res.emit('timeout', this);
                  const serverTimeout = this.server.emit('timeout', this);

                  if (!reqTimeout && !resTimeout && !serverTimeout)
                    this.destroy();
        },
              data: function () {
          [native code
          ]
        },
              error: function socketOnError(e) {
          // Ignore further errors
                this.removeListener('error', socketOnError);

                if (this.listenerCount('error', noop) === 0) {
                  this.on('error', noop);
          } else {
                  warnUnclosedSocket();
          }

                if (!this.server.emit('clientError', e, this)) {
            // Caution must be taken to avoid corrupting the remote peer.
            // Reply an error segment if there is no in-flight `ServerResponse`,
            // or no data of the in-flight one has been written yet to this socket.
                  if (this.writable &&
                    (!this._httpMessage || !this._httpMessage._headerSent)) {
                    let response;

                    switch (e.code) {
                      case 'HPE_HEADER_OVERFLOW':
                        response = requestHeaderFieldsTooLargeResponse;
                        break;
                      case 'HPE_CHUNK_EXTENSIONS_OVERFLOW':
                        response = requestChunkExtensionsTooLargeResponse;
                        break;
                      case 'ERR_HTTP_REQUEST_TIMEOUT':
                        response = requestTimeoutResponse;
                        break;
                      default:
                        response = badRequestResponse;
                        break;
              }

                    this.write(response);
            }
                  this.destroy(e);
          }
        },
              close: [
                function () {
            [native code
            ]
          },
                function onServerResponseClose() {
            // EventEmitter.emit makes a copy of the 'close' listeners array before
            // calling the listeners. detachSocket() unregisters onServerResponseClose
            // but if detachSocket() is called, directly or indirectly, by a 'close'
            // listener, onServerResponseClose is still in that copy of the listeners
            // array. That is, in the example below, b still gets called even though
            // it's been removed by a:
            //
            //   const EventEmitter = require('events');
            //   const obj = new EventEmitter();
            //   obj.on('event', a);
            //   obj.on('event', b);
            //   function a() { obj.removeListener('event', b) }
            //   function b() { throw "BAM!" }
            //   obj.emit('event');  // throws
            //
            // Ergo, we need to deal with stale 'close' events and handle the case
            // where the ServerResponse object has already been deconstructed.
            // Fortunately, that requires only a single if check. :-)
                  if (this._httpMessage) {
                    emitCloseNT(this._httpMessage);
            }
          },
        ],
                drain: function () {
          [native code
          ]
        },
              resume: function onSocketResume() {
          // It may seem that the socket is resumed, but this is an enemy's trick to
          // deceive us! `resume` is emitted asynchronously, and may be called from
          // `incoming.readStart()`. Stop the socket again here, just to preserve the
          // state.
          //
          // We don't care about stream semantics for the consumed socket anyway.
                if (this._paused) {
                  this.pause();
                  return;
          }

                if (this._handle && !this._handle.reading) {
                  this._handle.reading = true;
                  this._handle.readStart();
          }
        },
              pause: function onSocketPause() {
                if (this._handle && this._handle.reading) {
                  this._handle.reading = false;
                  this._handle.readStop();
          }
        },
      },
            _eventsCount: 8,
              _maxListeners: undefined,
                _writableState: {
              objectMode: false,
                highWaterMark: 16384,
                  finalCalled: false,
                    needDrain: false,
                      ending: false,
                        ended: false,
                          finished: false,
                            destroyed: false,
                              decodeStrings: false,
                                defaultEncoding: "utf8",
                                  length: 0,
                                    writing: false,
                                      corked: 0,
                                        sync: true,
                                          bufferProcessing: false,
                                            onwrite: function () {
          [native code
          ]
        },
              writecb: null,
                writelen: 0,
                  afterWriteTickInfo: null,
                    buffered: [],
                      bufferedIndex: 0,
                        allBuffers: true,
                          allNoop: true,
                            pendingcb: 0,
                              constructed: true,
                                prefinished: false,
                                  errorEmitted: false,
                                    emitClose: false,
                                      autoDestroy: true,
                                        errored: null,
                                          closed: false,
                                            closeEmitted: false,
      },
            allowHalfOpen: true,
              _sockname: null,
                _pendingData: null,
                  _pendingEncoding: "",
                    server: {
              maxHeaderSize: undefined,
                insecureHTTPParser: undefined,
                  requestTimeout: 300000,
                    headersTimeout: 60000,
                      keepAliveTimeout: 5000,
                        connectionsCheckingInterval: 30000,
                          joinDuplicateHeaders: undefined,
                            rejectNonStandardBodyWrites: false,
                              _events: {
                request: function(req, res, next) {
                  app.handle(req, res, next);
          },
                connection: function connectionListener(socket) {
                  defaultTriggerAsyncIdScope(
                    getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                  );
          },
                listening: [
                  function setupConnectionsTracking() {
              // Start connection handling
                    if (!this[kConnections
              ]) {
                      this[kConnections
                ] = new ConnectionsList();
              }
              // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
              // otherwise it would not be started if such timeouts are modified after createServer.
                    this[kConnectionsCheckingInterval
              ] =
                      setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
            },
                  function () {
              [native code
              ]
            },
          ],
                  error: function () {
            [native code
            ]
          },
                upgrade: (req, socket, head) => {
                  this.handleUpgrade(req, socket, head, emitConnection);
          },
        },
              _eventsCount: 5,
                _maxListeners: undefined,
                  _connections: 1,
                    _handle: {
                reading: false,
                  onconnection: function onconnection(err, clientHandle) {
                    const handle = this;
                    const self = handle[owner_symbol
            ];

                    debug('onconnection');

                    if (err) {
                      self.emit('error', errnoException(err, 'accept'));
                      return;
            }

                    if (self.maxConnections && self._connections >= self.maxConnections) {
                      if (clientHandle.getsockname || clientHandle.getpeername) {
                        const data = ObjectCreate(null);
                        if (clientHandle.getsockname) {
                          const localInfo = ObjectCreate(null);
                          clientHandle.getsockname(localInfo);
                          data.localAddress = localInfo.address;
                          data.localPort = localInfo.port;
                          data.localFamily = localInfo.family;
                }
                        if (clientHandle.getpeername) {
                          const remoteInfo = ObjectCreate(null);
                          clientHandle.getpeername(remoteInfo);
                          data.remoteAddress = remoteInfo.address;
                          data.remotePort = remoteInfo.port;
                          data.remoteFamily = remoteInfo.family;
                }
                        self.emit('drop', data);
              } else {
                        self.emit('drop');
              }
                      clientHandle.close();
                      return;
            }

                    const socket = new Socket({
                      handle: clientHandle,
                      allowHalfOpen: self.allowHalfOpen,
                      pauseOnCreate: self.pauseOnConnect,
                      readable: true,
                      writable: true,
                      readableHighWaterMark: self.highWaterMark,
                      writableHighWaterMark: self.highWaterMark,
            });

                    if (self.noDelay && clientHandle.setNoDelay) {
                      socket[kSetNoDelay
              ] = true;
                      clientHandle.setNoDelay(true);
            }
                    if (self.keepAlive && clientHandle.setKeepAlive) {
                      socket[kSetKeepAlive
              ] = true;
                      socket[kSetKeepAliveInitialDelay
              ] = self.keepAliveInitialDelay;
                      clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
            }

                    self._connections++;
                    socket.server = self;
                    socket._server = self;

                    DTRACE_NET_SERVER_CONNECTION(socket);
                    self.emit('connection', socket);
                    lazyChannels();
                    if (netServerSocketChannel.hasSubscribers) {
                      netServerSocketChannel.publish({
                        socket,
              });
            }
          },
        },
              _usingWorkers: false,
                _workers: [],
                  _unref: false,
                    allowHalfOpen: true,
                      pauseOnConnect: false,
                        noDelay: true,
                          keepAlive: false,
                            keepAliveInitialDelay: 0,
                              highWaterMark: 16384,
                                httpAllowHalfOpen: false,
                                  timeout: 0,
                                    maxHeadersCount: null,
                                      maxRequestsPerSocket: 0,
                                        _connectionKey: "6::::1394",
      },
            _server: {
              maxHeaderSize: undefined,
                insecureHTTPParser: undefined,
                  requestTimeout: 300000,
                    headersTimeout: 60000,
                      keepAliveTimeout: 5000,
                        connectionsCheckingInterval: 30000,
                          joinDuplicateHeaders: undefined,
                            rejectNonStandardBodyWrites: false,
                              _events: {
                request: function(req, res, next) {
                  app.handle(req, res, next);
          },
                connection: function connectionListener(socket) {
                  defaultTriggerAsyncIdScope(
                    getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                  );
          },
                listening: [
                  function setupConnectionsTracking() {
              // Start connection handling
                    if (!this[kConnections
              ]) {
                      this[kConnections
                ] = new ConnectionsList();
              }
              // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
              // otherwise it would not be started if such timeouts are modified after createServer.
                    this[kConnectionsCheckingInterval
              ] =
                      setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
            },
                  function () {
              [native code
              ]
            },
          ],
                  error: function () {
            [native code
            ]
          },
                upgrade: (req, socket, head) => {
                  this.handleUpgrade(req, socket, head, emitConnection);
          },
        },
              _eventsCount: 5,
                _maxListeners: undefined,
                  _connections: 1,
                    _handle: {
                reading: false,
                  onconnection: function onconnection(err, clientHandle) {
                    const handle = this;
                    const self = handle[owner_symbol
            ];

                    debug('onconnection');

                    if (err) {
                      self.emit('error', errnoException(err, 'accept'));
                      return;
            }

                    if (self.maxConnections && self._connections >= self.maxConnections) {
                      if (clientHandle.getsockname || clientHandle.getpeername) {
                        const data = ObjectCreate(null);
                        if (clientHandle.getsockname) {
                          const localInfo = ObjectCreate(null);
                          clientHandle.getsockname(localInfo);
                          data.localAddress = localInfo.address;
                          data.localPort = localInfo.port;
                          data.localFamily = localInfo.family;
                }
                        if (clientHandle.getpeername) {
                          const remoteInfo = ObjectCreate(null);
                          clientHandle.getpeername(remoteInfo);
                          data.remoteAddress = remoteInfo.address;
                          data.remotePort = remoteInfo.port;
                          data.remoteFamily = remoteInfo.family;
                }
                        self.emit('drop', data);
              } else {
                        self.emit('drop');
              }
                      clientHandle.close();
                      return;
            }

                    const socket = new Socket({
                      handle: clientHandle,
                      allowHalfOpen: self.allowHalfOpen,
                      pauseOnCreate: self.pauseOnConnect,
                      readable: true,
                      writable: true,
                      readableHighWaterMark: self.highWaterMark,
                      writableHighWaterMark: self.highWaterMark,
            });

                    if (self.noDelay && clientHandle.setNoDelay) {
                      socket[kSetNoDelay
              ] = true;
                      clientHandle.setNoDelay(true);
            }
                    if (self.keepAlive && clientHandle.setKeepAlive) {
                      socket[kSetKeepAlive
              ] = true;
                      socket[kSetKeepAliveInitialDelay
              ] = self.keepAliveInitialDelay;
                      clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
            }

                    self._connections++;
                    socket.server = self;
                    socket._server = self;

                    DTRACE_NET_SERVER_CONNECTION(socket);
                    self.emit('connection', socket);
                    lazyChannels();
                    if (netServerSocketChannel.hasSubscribers) {
                      netServerSocketChannel.publish({
                        socket,
              });
            }
          },
        },
              _usingWorkers: false,
                _workers: [],
                  _unref: false,
                    allowHalfOpen: true,
                      pauseOnConnect: false,
                        noDelay: true,
                          keepAlive: false,
                            keepAliveInitialDelay: 0,
                              highWaterMark: 16384,
                                httpAllowHalfOpen: false,
                                  timeout: 0,
                                    maxHeadersCount: null,
                                      maxRequestsPerSocket: 0,
                                        _connectionKey: "6::::1394",
      },
            parser: {
        "0": null,
        "1": function parserOnHeaders(headers, url) {
          // Once we exceeded headers limit - stop collecting them
                  if (this.maxHeaderPairs <= 0 ||
                    this._headers.length < this.maxHeaderPairs) {
                    this._headers.push(...headers);
          }
                  this._url += url;
        },
        "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                url, statusCode, statusMessage, upgrade,
                shouldKeepAlive) {
                const parser = this;
                const { socket
          } = parser;

                if (headers === undefined) {
                  headers = parser._headers;
                  parser._headers = [];
          }

                if (url === undefined) {
                  url = parser._url;
                  parser._url = '';
          }
          // Parser is also used by http client
                const ParserIncomingMessage = (socket && socket.server &&
                  socket.server[kIncomingMessage
          ]) ||
                  IncomingMessage;

                const incoming = parser.incoming = new ParserIncomingMessage(socket);
                incoming.httpVersionMajor = versionMajor;
                incoming.httpVersionMinor = versionMinor;
                incoming.httpVersion = `${versionMajor
          }.${versionMinor
          }`;
                incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
                  parser.joinDuplicateHeaders;
                incoming.url = url;
                incoming.upgrade = upgrade;

                let n = headers.length;

                // If parser.maxHeaderPairs <= 0 assume that there's no limit.
                if (parser.maxHeaderPairs > 0)
                  n = MathMin(n, parser.maxHeaderPairs);

                incoming._addHeaderLines(headers, n);

                if (typeof method === 'number') {
            // server only
                  incoming.method = methods[method
            ];
          } else {
            // client only
                  incoming.statusCode = statusCode;
                  incoming.statusMessage = statusMessage;
          }

                return parser.onIncoming(incoming, shouldKeepAlive);
        },
        "3": function parserOnBody(b) {
                const stream = this.incoming;

                // If the stream has already been removed, then drop it.
                if (stream === null)
                  return;

                // Pretend this was the result of a stream._read call.
                if (!stream._dumped) {
                  const ret = stream.push(b);
                  if (!ret)
                    readStop(this.socket);
          }
        },
        "4": function parserOnMessageComplete() {
                const parser = this;
                const stream = parser.incoming;

                if (stream !== null) {
                  stream.complete = true;
                  // Emit any trailing headers.
                  const headers = parser._headers;
                  if (headers.length) {
                    stream._addHeaderLines(headers, headers.length);
                    parser._headers = [];
                    parser._url = '';
            }
            // For emit end event
                  stream.push(null);
          }
          // Force to read the next incoming message
                readStart(parser.socket);
        },
        "5": function () {
          [native code
          ]
        },
        "6": function () {
          [native code
          ]
        },
              _headers: [],
                _url: "",
                  socket: [Circular
        ],
                    incoming: {
                _readableState: {
                  state: 137266,
                    highWaterMark: 16384,
                      buffer: {
                    head: null,
                      tail: null,
                        length: 0,
            },
                  length: 0,
                    pipes: [],
                      flowing: null,
                        errored: null,
                          defaultEncoding: "utf8",
                            awaitDrainWriters: null,
                              decoder: null,
                                encoding: null,
          },
                _events: {},
                _eventsCount: 0,
                  _maxListeners: undefined,
                    socket: [Circular
          ],
                      httpVersionMajor: 1,
                        httpVersionMinor: 1,
                          httpVersion: "1.1",
                            complete: true,
                              rawHeaders: [
            "Accept",
            "application/json, text/plain, */*",
            "User-Agent",
            "axios/0.24.0",
            "Host",
            "abounak.local:1394",
            "Connection",
            "close",
          ],
                                rawTrailers: [],
                                  joinDuplicateHeaders: null,
                                    aborted: false,
                                      upgrade: false,
                                        url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                          method: "GET",
                                            statusCode: null,
                                              statusMessage: null,
                                                client: [Circular
          ],
                                                  _consuming: false,
                                                    _dumped: false,
                                                      next: function next(err) {
                                                        var layerError = err === 'route'
                                                          ? null
                                                          : err;

                                                        // remove added slash
                                                        if (slashAdded) {
                                                          req.url = req.url.slice(1)
                                                          slashAdded = false;
            }
            // restore altered req.url
                                                        if (removed.length !== 0) {
                                                          req.baseUrl = parentUrl;
                                                          req.url = protohost + removed + req.url.slice(protohost.length)
                                                          removed = '';
            }
            // signal to exit router
                                                        if (layerError === 'router') {
                                                          setImmediate(done, null)
                                                          return
            }
            // no more matching layers
                                                        if (idx >= stack.length) {
                                                          setImmediate(done, layerError);
                                                          return;
            }
            // max sync stack
                                                        if (++sync > 100) {
                                                          return setImmediate(next, err)
            }
            // get pathname of request
                                                        var path = getPathname(req);

                                                        if (path == null) {
                                                          return done(layerError);
            }
            // find next matching layer
                                                        var layer;
                                                        var match;
                                                        var route;

                                                        while (match !== true && idx < stack.length) {
                                                          layer = stack[idx++
              ];
                                                          match = matchLayer(layer, path);
                                                          route = layer.route;

                                                          if (typeof match !== 'boolean') {
                // hold on to layerError
                                                            layerError = layerError || match;
              }

                                                          if (match !== true) {
                                                            continue;
              }

                                                          if (!route) {
                // process non-route handlers normally
                                                            continue;
              }

                                                          if (layerError) {
                // routes do not match with a pending error
                                                            match = false;
                                                            continue;
              }

                                                          var method = req.method;
                                                          var has_method = route._handles_method(method);

                                                          // build up automatic options response
                                                          if (!has_method && method === 'OPTIONS') {
                                                            appendMethods(options, route._options());
              }
              // don't even bother matching route
                                                          if (!has_method && method !== 'HEAD') {
                                                            match = false;
              }
            }
            // no match
                                                        if (match !== true) {
                                                          return done(layerError);
            }
            // store route for dispatch on change
                                                        if (route) {
                                                          req.route = route;
            }
            // Capture one-time layer values
                                                        req.params = self.mergeParams
                                                          ? mergeParams(layer.params, parentParams)
                                                          : layer.params;
                                                        var layerPath = layer.path;

                                                        // this should be done for the layer
                                                        self.process_params(layer, paramcalled, req, res, function (err) {
                                                          if (err) {
                                                            next(layerError || err)
              } else if (route) {
                                                            layer.handle_request(req, res, next)
              } else {
                                                            trim_prefix(layer, layerError, layerPath, path)
              }

                                                          sync = 0
            });
          },
                baseUrl: "",
                  originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                    _parsedUrl: {
                  protocol: null,
                    slashes: null,
                      auth: null,
                        host: null,
                          port: null,
                            hostname: null,
                              hash: null,
                                search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                  query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                    pathname: "/parseUserMe",
                                      path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                        href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                          _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
          },
                params: {},
                query: {
                  usersession: "r:255111ff859d0977bb5b94ce2782d69d",
                    include: "entity",
          },
                res: [Circular
          ],
                  body: {},
                route: {
                  path: "/parseuserme",
                    stack: [
              {
                        handle: (req, res, next) => {
                          let key = '__express__' + req.originalUrl || req.url
                          let cachedBody = mcache.get(key)
                          if (cachedBody) {
                            res.send(cachedBody)
                            return
                  } else {
                            res.sendResponse = res.send
                            res.send = (body) => {
                              mcache.put(key, body, duration * 1000);
                              res.sendResponse(body)
                    }
                            next()
                  }
                },
                        name: "<anonymous>",
                        params: undefined,
                        path: undefined,
                        keys: [],
                        regexp: {
                          fast_star: false,
                          fast_slash: false,
                },
                        method: "get",
              },
              {
                        handle: async (request, response, next) => {
                          try {
                            await Promise.resolve(fn(request, response, next)).catch(next);
                  } catch (error) {
                            next(error);
                  }
                },
                        name: "<anonymous>",
                        params: undefined,
                        path: undefined,
                        keys: [],
                        regexp: {
                          fast_star: false,
                          fast_slash: false,
                },
                        method: "get",
              },
              {
                        handle: async (request, response, next) => {
                          await doHandle({ handler, request, response, next
                  })
                },
                        name: "<anonymous>",
                        params: undefined,
                        path: undefined,
                        keys: [],
                        regexp: {
                          fast_star: false,
                          fast_slash: false,
                },
                        method: "get",
              },
            ],
                      methods: {
                    get: true,
            },
          },
                rateLimit: {
                  limit: 1000,
                    used: 1,
                      remaining: 999,
                        resetTime: "2024-07-19T11:30:07.125Z",
          },
        },
              outgoing: null,
                maxHeaderPairs: 2000,
                  _consumed: true,
                    onIncoming: function () {
          [native code
          ]
        },
              joinDuplicateHeaders: null,
      },
            on: function socketListenerWrap(ev, fn) {
              const res = net.Socket.prototype[originalFnName
        ].call(this,
                ev, fn);
              if (!this.parser) {
                this.on = net.Socket.prototype.on;
                this.addListener = net.Socket.prototype.addListener;
                this.prependListener = net.Socket.prototype.prependListener;
                return res;
        }

              if (ev === 'data' || ev === 'readable')
                unconsume(this.parser, this);

              return res;
      },
            addListener: function socketListenerWrap(ev, fn) {
              const res = net.Socket.prototype[originalFnName
        ].call(this,
                ev, fn);
              if (!this.parser) {
                this.on = net.Socket.prototype.on;
                this.addListener = net.Socket.prototype.addListener;
                this.prependListener = net.Socket.prototype.prependListener;
                return res;
        }

              if (ev === 'data' || ev === 'readable')
                unconsume(this.parser, this);

              return res;
      },
            prependListener: function socketListenerWrap(ev, fn) {
              const res = net.Socket.prototype[originalFnName
        ].call(this,
                ev, fn);
              if (!this.parser) {
                this.on = net.Socket.prototype.on;
                this.addListener = net.Socket.prototype.addListener;
                this.prependListener = net.Socket.prototype.prependListener;
                return res;
        }

              if (ev === 'data' || ev === 'readable')
                unconsume(this.parser, this);

              return res;
      },
            setEncoding: function socketSetEncoding() {
              throw new ERR_HTTP_SOCKET_ENCODING();
      },
            _paused: false,
              _httpMessage: [Circular
      ],
                _peername: {
              address: "::1",
                family: "IPv6",
                  port: 56041,
      },
    },
          _header: null,
            _keepAliveTimeout: 5000,
              _onPendingData: function () {
      [native code
      ]
    },
          req: {
            _readableState: {
              state: 137266,
                highWaterMark: 16384,
                  buffer: {
                head: null,
                  tail: null,
                    length: 0,
        },
              length: 0,
                pipes: [],
                  flowing: null,
                    errored: null,
                      defaultEncoding: "utf8",
                        awaitDrainWriters: null,
                          decoder: null,
                            encoding: null,
      },
            _events: {},
            _eventsCount: 0,
              _maxListeners: undefined,
                socket: {
              connecting: false,
                _hadError: false,
                  _parent: null,
                    _host: null,
                      _closeAfterHandlingError: false,
                        _readableState: {
                state: 4184,
                  highWaterMark: 16384,
                    buffer: {
                  head: null,
                    tail: null,
                      length: 0,
          },
                length: 0,
                  pipes: [],
                    flowing: true,
                      errored: null,
                        defaultEncoding: "utf8",
                          awaitDrainWriters: null,
                            decoder: null,
                              encoding: null,
        },
              _events: {
                end: [
                  function onReadableStreamEnd() {
                    if (!this.allowHalfOpen) {
                      this.write = writeAfterFIN;
              }
            },
                  function () {
              [native code
              ]
            },
          ],
                  timeout: function socketOnTimeout() {
                    const req = this.parser && this.parser.incoming;
                    const reqTimeout = req && !req.complete && req.emit('timeout', this);
                    const res = this._httpMessage;
                    const resTimeout = res && res.emit('timeout', this);
                    const serverTimeout = this.server.emit('timeout', this);

                    if (!reqTimeout && !resTimeout && !serverTimeout)
                      this.destroy();
          },
                data: function () {
            [native code
            ]
          },
                error: function socketOnError(e) {
            // Ignore further errors
                  this.removeListener('error', socketOnError);

                  if (this.listenerCount('error', noop) === 0) {
                    this.on('error', noop);
            } else {
                    warnUnclosedSocket();
            }

                  if (!this.server.emit('clientError', e, this)) {
              // Caution must be taken to avoid corrupting the remote peer.
              // Reply an error segment if there is no in-flight `ServerResponse`,
              // or no data of the in-flight one has been written yet to this socket.
                    if (this.writable &&
                      (!this._httpMessage || !this._httpMessage._headerSent)) {
                      let response;

                      switch (e.code) {
                        case 'HPE_HEADER_OVERFLOW':
                          response = requestHeaderFieldsTooLargeResponse;
                          break;
                        case 'HPE_CHUNK_EXTENSIONS_OVERFLOW':
                          response = requestChunkExtensionsTooLargeResponse;
                          break;
                        case 'ERR_HTTP_REQUEST_TIMEOUT':
                          response = requestTimeoutResponse;
                          break;
                        default:
                          response = badRequestResponse;
                          break;
                }

                      this.write(response);
              }
                    this.destroy(e);
            }
          },
                close: [
                  function () {
              [native code
              ]
            },
                  function onServerResponseClose() {
              // EventEmitter.emit makes a copy of the 'close' listeners array before
              // calling the listeners. detachSocket() unregisters onServerResponseClose
              // but if detachSocket() is called, directly or indirectly, by a 'close'
              // listener, onServerResponseClose is still in that copy of the listeners
              // array. That is, in the example below, b still gets called even though
              // it's been removed by a:
              //
              //   const EventEmitter = require('events');
              //   const obj = new EventEmitter();
              //   obj.on('event', a);
              //   obj.on('event', b);
              //   function a() { obj.removeListener('event', b) }
              //   function b() { throw "BAM!" }
              //   obj.emit('event');  // throws
              //
              // Ergo, we need to deal with stale 'close' events and handle the case
              // where the ServerResponse object has already been deconstructed.
              // Fortunately, that requires only a single if check. :-)
                    if (this._httpMessage) {
                      emitCloseNT(this._httpMessage);
              }
            },
          ],
                  drain: function () {
            [native code
            ]
          },
                resume: function onSocketResume() {
            // It may seem that the socket is resumed, but this is an enemy's trick to
            // deceive us! `resume` is emitted asynchronously, and may be called from
            // `incoming.readStart()`. Stop the socket again here, just to preserve the
            // state.
            //
            // We don't care about stream semantics for the consumed socket anyway.
                  if (this._paused) {
                    this.pause();
                    return;
            }

                  if (this._handle && !this._handle.reading) {
                    this._handle.reading = true;
                    this._handle.readStart();
            }
          },
                pause: function onSocketPause() {
                  if (this._handle && this._handle.reading) {
                    this._handle.reading = false;
                    this._handle.readStop();
            }
          },
        },
              _eventsCount: 8,
                _maxListeners: undefined,
                  _writableState: {
                objectMode: false,
                  highWaterMark: 16384,
                    finalCalled: false,
                      needDrain: false,
                        ending: false,
                          ended: false,
                            finished: false,
                              destroyed: false,
                                decodeStrings: false,
                                  defaultEncoding: "utf8",
                                    length: 0,
                                      writing: false,
                                        corked: 0,
                                          sync: true,
                                            bufferProcessing: false,
                                              onwrite: function () {
            [native code
            ]
          },
                writecb: null,
                  writelen: 0,
                    afterWriteTickInfo: null,
                      buffered: [],
                        bufferedIndex: 0,
                          allBuffers: true,
                            allNoop: true,
                              pendingcb: 0,
                                constructed: true,
                                  prefinished: false,
                                    errorEmitted: false,
                                      emitClose: false,
                                        autoDestroy: true,
                                          errored: null,
                                            closed: false,
                                              closeEmitted: false,
        },
              allowHalfOpen: true,
                _sockname: null,
                  _pendingData: null,
                    _pendingEncoding: "",
                      server: {
                maxHeaderSize: undefined,
                  insecureHTTPParser: undefined,
                    requestTimeout: 300000,
                      headersTimeout: 60000,
                        keepAliveTimeout: 5000,
                          connectionsCheckingInterval: 30000,
                            joinDuplicateHeaders: undefined,
                              rejectNonStandardBodyWrites: false,
                                _events: {
                  request: function(req, res, next) {
                    app.handle(req, res, next);
            },
                  connection: function connectionListener(socket) {
                    defaultTriggerAsyncIdScope(
                      getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                    );
            },
                  listening: [
                    function setupConnectionsTracking() {
                // Start connection handling
                      if (!this[kConnections
                ]) {
                        this[kConnections
                  ] = new ConnectionsList();
                }
                // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
                // otherwise it would not be started if such timeouts are modified after createServer.
                      this[kConnectionsCheckingInterval
                ] =
                        setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
              },
                    function () {
                [native code
                ]
              },
            ],
                    error: function () {
              [native code
              ]
            },
                  upgrade: (req, socket, head) => {
                    this.handleUpgrade(req, socket, head, emitConnection);
            },
          },
                _eventsCount: 5,
                  _maxListeners: undefined,
                    _connections: 1,
                      _handle: {
                  reading: false,
                    onconnection: function onconnection(err, clientHandle) {
                      const handle = this;
                      const self = handle[owner_symbol
              ];

                      debug('onconnection');

                      if (err) {
                        self.emit('error', errnoException(err, 'accept'));
                        return;
              }

                      if (self.maxConnections && self._connections >= self.maxConnections) {
                        if (clientHandle.getsockname || clientHandle.getpeername) {
                          const data = ObjectCreate(null);
                          if (clientHandle.getsockname) {
                            const localInfo = ObjectCreate(null);
                            clientHandle.getsockname(localInfo);
                            data.localAddress = localInfo.address;
                            data.localPort = localInfo.port;
                            data.localFamily = localInfo.family;
                  }
                          if (clientHandle.getpeername) {
                            const remoteInfo = ObjectCreate(null);
                            clientHandle.getpeername(remoteInfo);
                            data.remoteAddress = remoteInfo.address;
                            data.remotePort = remoteInfo.port;
                            data.remoteFamily = remoteInfo.family;
                  }
                          self.emit('drop', data);
                } else {
                          self.emit('drop');
                }
                        clientHandle.close();
                        return;
              }

                      const socket = new Socket({
                        handle: clientHandle,
                        allowHalfOpen: self.allowHalfOpen,
                        pauseOnCreate: self.pauseOnConnect,
                        readable: true,
                        writable: true,
                        readableHighWaterMark: self.highWaterMark,
                        writableHighWaterMark: self.highWaterMark,
              });

                      if (self.noDelay && clientHandle.setNoDelay) {
                        socket[kSetNoDelay
                ] = true;
                        clientHandle.setNoDelay(true);
              }
                      if (self.keepAlive && clientHandle.setKeepAlive) {
                        socket[kSetKeepAlive
                ] = true;
                        socket[kSetKeepAliveInitialDelay
                ] = self.keepAliveInitialDelay;
                        clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
              }

                      self._connections++;
                      socket.server = self;
                      socket._server = self;

                      DTRACE_NET_SERVER_CONNECTION(socket);
                      self.emit('connection', socket);
                      lazyChannels();
                      if (netServerSocketChannel.hasSubscribers) {
                        netServerSocketChannel.publish({
                          socket,
                });
              }
            },
          },
                _usingWorkers: false,
                  _workers: [],
                    _unref: false,
                      allowHalfOpen: true,
                        pauseOnConnect: false,
                          noDelay: true,
                            keepAlive: false,
                              keepAliveInitialDelay: 0,
                                highWaterMark: 16384,
                                  httpAllowHalfOpen: false,
                                    timeout: 0,
                                      maxHeadersCount: null,
                                        maxRequestsPerSocket: 0,
                                          _connectionKey: "6::::1394",
        },
              _server: {
                maxHeaderSize: undefined,
                  insecureHTTPParser: undefined,
                    requestTimeout: 300000,
                      headersTimeout: 60000,
                        keepAliveTimeout: 5000,
                          connectionsCheckingInterval: 30000,
                            joinDuplicateHeaders: undefined,
                              rejectNonStandardBodyWrites: false,
                                _events: {
                  request: function(req, res, next) {
                    app.handle(req, res, next);
            },
                  connection: function connectionListener(socket) {
                    defaultTriggerAsyncIdScope(
                      getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                    );
            },
                  listening: [
                    function setupConnectionsTracking() {
                // Start connection handling
                      if (!this[kConnections
                ]) {
                        this[kConnections
                  ] = new ConnectionsList();
                }
                // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
                // otherwise it would not be started if such timeouts are modified after createServer.
                      this[kConnectionsCheckingInterval
                ] =
                        setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
              },
                    function () {
                [native code
                ]
              },
            ],
                    error: function () {
              [native code
              ]
            },
                  upgrade: (req, socket, head) => {
                    this.handleUpgrade(req, socket, head, emitConnection);
            },
          },
                _eventsCount: 5,
                  _maxListeners: undefined,
                    _connections: 1,
                      _handle: {
                  reading: false,
                    onconnection: function onconnection(err, clientHandle) {
                      const handle = this;
                      const self = handle[owner_symbol
              ];

                      debug('onconnection');

                      if (err) {
                        self.emit('error', errnoException(err, 'accept'));
                        return;
              }

                      if (self.maxConnections && self._connections >= self.maxConnections) {
                        if (clientHandle.getsockname || clientHandle.getpeername) {
                          const data = ObjectCreate(null);
                          if (clientHandle.getsockname) {
                            const localInfo = ObjectCreate(null);
                            clientHandle.getsockname(localInfo);
                            data.localAddress = localInfo.address;
                            data.localPort = localInfo.port;
                            data.localFamily = localInfo.family;
                  }
                          if (clientHandle.getpeername) {
                            const remoteInfo = ObjectCreate(null);
                            clientHandle.getpeername(remoteInfo);
                            data.remoteAddress = remoteInfo.address;
                            data.remotePort = remoteInfo.port;
                            data.remoteFamily = remoteInfo.family;
                  }
                          self.emit('drop', data);
                } else {
                          self.emit('drop');
                }
                        clientHandle.close();
                        return;
              }

                      const socket = new Socket({
                        handle: clientHandle,
                        allowHalfOpen: self.allowHalfOpen,
                        pauseOnCreate: self.pauseOnConnect,
                        readable: true,
                        writable: true,
                        readableHighWaterMark: self.highWaterMark,
                        writableHighWaterMark: self.highWaterMark,
              });

                      if (self.noDelay && clientHandle.setNoDelay) {
                        socket[kSetNoDelay
                ] = true;
                        clientHandle.setNoDelay(true);
              }
                      if (self.keepAlive && clientHandle.setKeepAlive) {
                        socket[kSetKeepAlive
                ] = true;
                        socket[kSetKeepAliveInitialDelay
                ] = self.keepAliveInitialDelay;
                        clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
              }

                      self._connections++;
                      socket.server = self;
                      socket._server = self;

                      DTRACE_NET_SERVER_CONNECTION(socket);
                      self.emit('connection', socket);
                      lazyChannels();
                      if (netServerSocketChannel.hasSubscribers) {
                        netServerSocketChannel.publish({
                          socket,
                });
              }
            },
          },
                _usingWorkers: false,
                  _workers: [],
                    _unref: false,
                      allowHalfOpen: true,
                        pauseOnConnect: false,
                          noDelay: true,
                            keepAlive: false,
                              keepAliveInitialDelay: 0,
                                highWaterMark: 16384,
                                  httpAllowHalfOpen: false,
                                    timeout: 0,
                                      maxHeadersCount: null,
                                        maxRequestsPerSocket: 0,
                                          _connectionKey: "6::::1394",
        },
              parser: {
          "0": null,
          "1": function parserOnHeaders(headers, url) {
            // Once we exceeded headers limit - stop collecting them
                    if (this.maxHeaderPairs <= 0 ||
                      this._headers.length < this.maxHeaderPairs) {
                      this._headers.push(...headers);
            }
                    this._url += url;
          },
          "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                  url, statusCode, statusMessage, upgrade,
                  shouldKeepAlive) {
                  const parser = this;
                  const { socket
            } = parser;

                  if (headers === undefined) {
                    headers = parser._headers;
                    parser._headers = [];
            }

                  if (url === undefined) {
                    url = parser._url;
                    parser._url = '';
            }
            // Parser is also used by http client
                  const ParserIncomingMessage = (socket && socket.server &&
                    socket.server[kIncomingMessage
            ]) ||
                    IncomingMessage;

                  const incoming = parser.incoming = new ParserIncomingMessage(socket);
                  incoming.httpVersionMajor = versionMajor;
                  incoming.httpVersionMinor = versionMinor;
                  incoming.httpVersion = `${versionMajor
            }.${versionMinor
            }`;
                  incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
                    parser.joinDuplicateHeaders;
                  incoming.url = url;
                  incoming.upgrade = upgrade;

                  let n = headers.length;

                  // If parser.maxHeaderPairs <= 0 assume that there's no limit.
                  if (parser.maxHeaderPairs > 0)
                    n = MathMin(n, parser.maxHeaderPairs);

                  incoming._addHeaderLines(headers, n);

                  if (typeof method === 'number') {
              // server only
                    incoming.method = methods[method
              ];
            } else {
              // client only
                    incoming.statusCode = statusCode;
                    incoming.statusMessage = statusMessage;
            }

                  return parser.onIncoming(incoming, shouldKeepAlive);
          },
          "3": function parserOnBody(b) {
                  const stream = this.incoming;

                  // If the stream has already been removed, then drop it.
                  if (stream === null)
                    return;

                  // Pretend this was the result of a stream._read call.
                  if (!stream._dumped) {
                    const ret = stream.push(b);
                    if (!ret)
                      readStop(this.socket);
            }
          },
          "4": function parserOnMessageComplete() {
                  const parser = this;
                  const stream = parser.incoming;

                  if (stream !== null) {
                    stream.complete = true;
                    // Emit any trailing headers.
                    const headers = parser._headers;
                    if (headers.length) {
                      stream._addHeaderLines(headers, headers.length);
                      parser._headers = [];
                      parser._url = '';
              }
              // For emit end event
                    stream.push(null);
            }
            // Force to read the next incoming message
                  readStart(parser.socket);
          },
          "5": function () {
            [native code
            ]
          },
          "6": function () {
            [native code
            ]
          },
                _headers: [],
                  _url: "",
                    socket: [Circular
          ],
                      incoming: [Circular
          ],
                        outgoing: null,
                          maxHeaderPairs: 2000,
                            _consumed: true,
                              onIncoming: function () {
            [native code
            ]
          },
                joinDuplicateHeaders: null,
        },
              on: function socketListenerWrap(ev, fn) {
                const res = net.Socket.prototype[originalFnName
          ].call(this,
                  ev, fn);
                if (!this.parser) {
                  this.on = net.Socket.prototype.on;
                  this.addListener = net.Socket.prototype.addListener;
                  this.prependListener = net.Socket.prototype.prependListener;
                  return res;
          }

                if (ev === 'data' || ev === 'readable')
                  unconsume(this.parser, this);

                return res;
        },
              addListener: function socketListenerWrap(ev, fn) {
                const res = net.Socket.prototype[originalFnName
          ].call(this,
                  ev, fn);
                if (!this.parser) {
                  this.on = net.Socket.prototype.on;
                  this.addListener = net.Socket.prototype.addListener;
                  this.prependListener = net.Socket.prototype.prependListener;
                  return res;
          }

                if (ev === 'data' || ev === 'readable')
                  unconsume(this.parser, this);

                return res;
        },
              prependListener: function socketListenerWrap(ev, fn) {
                const res = net.Socket.prototype[originalFnName
          ].call(this,
                  ev, fn);
                if (!this.parser) {
                  this.on = net.Socket.prototype.on;
                  this.addListener = net.Socket.prototype.addListener;
                  this.prependListener = net.Socket.prototype.prependListener;
                  return res;
          }

                if (ev === 'data' || ev === 'readable')
                  unconsume(this.parser, this);

                return res;
        },
              setEncoding: function socketSetEncoding() {
                throw new ERR_HTTP_SOCKET_ENCODING();
        },
              _paused: false,
                _httpMessage: [Circular
        ],
                  _peername: {
                address: "::1",
                  family: "IPv6",
                    port: 56041,
        },
      },
            httpVersionMajor: 1,
              httpVersionMinor: 1,
                httpVersion: "1.1",
                  complete: true,
                    rawHeaders: [
        "Accept",
        "application/json, text/plain, */*",
        "User-Agent",
        "axios/0.24.0",
        "Host",
        "abounak.local:1394",
        "Connection",
        "close",
      ],
                      rawTrailers: [],
                        joinDuplicateHeaders: null,
                          aborted: false,
                            upgrade: false,
                              url: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                method: "GET",
                                  statusCode: null,
                                    statusMessage: null,
                                      client: {
              connecting: false,
                _hadError: false,
                  _parent: null,
                    _host: null,
                      _closeAfterHandlingError: false,
                        _readableState: {
                state: 4184,
                  highWaterMark: 16384,
                    buffer: {
                  head: null,
                    tail: null,
                      length: 0,
          },
                length: 0,
                  pipes: [],
                    flowing: true,
                      errored: null,
                        defaultEncoding: "utf8",
                          awaitDrainWriters: null,
                            decoder: null,
                              encoding: null,
        },
              _events: {
                end: [
                  function onReadableStreamEnd() {
                    if (!this.allowHalfOpen) {
                      this.write = writeAfterFIN;
              }
            },
                  function () {
              [native code
              ]
            },
          ],
                  timeout: function socketOnTimeout() {
                    const req = this.parser && this.parser.incoming;
                    const reqTimeout = req && !req.complete && req.emit('timeout', this);
                    const res = this._httpMessage;
                    const resTimeout = res && res.emit('timeout', this);
                    const serverTimeout = this.server.emit('timeout', this);

                    if (!reqTimeout && !resTimeout && !serverTimeout)
                      this.destroy();
          },
                data: function () {
            [native code
            ]
          },
                error: function socketOnError(e) {
            // Ignore further errors
                  this.removeListener('error', socketOnError);

                  if (this.listenerCount('error', noop) === 0) {
                    this.on('error', noop);
            } else {
                    warnUnclosedSocket();
            }

                  if (!this.server.emit('clientError', e, this)) {
              // Caution must be taken to avoid corrupting the remote peer.
              // Reply an error segment if there is no in-flight `ServerResponse`,
              // or no data of the in-flight one has been written yet to this socket.
                    if (this.writable &&
                      (!this._httpMessage || !this._httpMessage._headerSent)) {
                      let response;

                      switch (e.code) {
                        case 'HPE_HEADER_OVERFLOW':
                          response = requestHeaderFieldsTooLargeResponse;
                          break;
                        case 'HPE_CHUNK_EXTENSIONS_OVERFLOW':
                          response = requestChunkExtensionsTooLargeResponse;
                          break;
                        case 'ERR_HTTP_REQUEST_TIMEOUT':
                          response = requestTimeoutResponse;
                          break;
                        default:
                          response = badRequestResponse;
                          break;
                }

                      this.write(response);
              }
                    this.destroy(e);
            }
          },
                close: [
                  function () {
              [native code
              ]
            },
                  function onServerResponseClose() {
              // EventEmitter.emit makes a copy of the 'close' listeners array before
              // calling the listeners. detachSocket() unregisters onServerResponseClose
              // but if detachSocket() is called, directly or indirectly, by a 'close'
              // listener, onServerResponseClose is still in that copy of the listeners
              // array. That is, in the example below, b still gets called even though
              // it's been removed by a:
              //
              //   const EventEmitter = require('events');
              //   const obj = new EventEmitter();
              //   obj.on('event', a);
              //   obj.on('event', b);
              //   function a() { obj.removeListener('event', b) }
              //   function b() { throw "BAM!" }
              //   obj.emit('event');  // throws
              //
              // Ergo, we need to deal with stale 'close' events and handle the case
              // where the ServerResponse object has already been deconstructed.
              // Fortunately, that requires only a single if check. :-)
                    if (this._httpMessage) {
                      emitCloseNT(this._httpMessage);
              }
            },
          ],
                  drain: function () {
            [native code
            ]
          },
                resume: function onSocketResume() {
            // It may seem that the socket is resumed, but this is an enemy's trick to
            // deceive us! `resume` is emitted asynchronously, and may be called from
            // `incoming.readStart()`. Stop the socket again here, just to preserve the
            // state.
            //
            // We don't care about stream semantics for the consumed socket anyway.
                  if (this._paused) {
                    this.pause();
                    return;
            }

                  if (this._handle && !this._handle.reading) {
                    this._handle.reading = true;
                    this._handle.readStart();
            }
          },
                pause: function onSocketPause() {
                  if (this._handle && this._handle.reading) {
                    this._handle.reading = false;
                    this._handle.readStop();
            }
          },
        },
              _eventsCount: 8,
                _maxListeners: undefined,
                  _writableState: {
                objectMode: false,
                  highWaterMark: 16384,
                    finalCalled: false,
                      needDrain: false,
                        ending: false,
                          ended: false,
                            finished: false,
                              destroyed: false,
                                decodeStrings: false,
                                  defaultEncoding: "utf8",
                                    length: 0,
                                      writing: false,
                                        corked: 0,
                                          sync: true,
                                            bufferProcessing: false,
                                              onwrite: function () {
            [native code
            ]
          },
                writecb: null,
                  writelen: 0,
                    afterWriteTickInfo: null,
                      buffered: [],
                        bufferedIndex: 0,
                          allBuffers: true,
                            allNoop: true,
                              pendingcb: 0,
                                constructed: true,
                                  prefinished: false,
                                    errorEmitted: false,
                                      emitClose: false,
                                        autoDestroy: true,
                                          errored: null,
                                            closed: false,
                                              closeEmitted: false,
        },
              allowHalfOpen: true,
                _sockname: null,
                  _pendingData: null,
                    _pendingEncoding: "",
                      server: {
                maxHeaderSize: undefined,
                  insecureHTTPParser: undefined,
                    requestTimeout: 300000,
                      headersTimeout: 60000,
                        keepAliveTimeout: 5000,
                          connectionsCheckingInterval: 30000,
                            joinDuplicateHeaders: undefined,
                              rejectNonStandardBodyWrites: false,
                                _events: {
                  request: function(req, res, next) {
                    app.handle(req, res, next);
            },
                  connection: function connectionListener(socket) {
                    defaultTriggerAsyncIdScope(
                      getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                    );
            },
                  listening: [
                    function setupConnectionsTracking() {
                // Start connection handling
                      if (!this[kConnections
                ]) {
                        this[kConnections
                  ] = new ConnectionsList();
                }
                // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
                // otherwise it would not be started if such timeouts are modified after createServer.
                      this[kConnectionsCheckingInterval
                ] =
                        setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
              },
                    function () {
                [native code
                ]
              },
            ],
                    error: function () {
              [native code
              ]
            },
                  upgrade: (req, socket, head) => {
                    this.handleUpgrade(req, socket, head, emitConnection);
            },
          },
                _eventsCount: 5,
                  _maxListeners: undefined,
                    _connections: 1,
                      _handle: {
                  reading: false,
                    onconnection: function onconnection(err, clientHandle) {
                      const handle = this;
                      const self = handle[owner_symbol
              ];

                      debug('onconnection');

                      if (err) {
                        self.emit('error', errnoException(err, 'accept'));
                        return;
              }

                      if (self.maxConnections && self._connections >= self.maxConnections) {
                        if (clientHandle.getsockname || clientHandle.getpeername) {
                          const data = ObjectCreate(null);
                          if (clientHandle.getsockname) {
                            const localInfo = ObjectCreate(null);
                            clientHandle.getsockname(localInfo);
                            data.localAddress = localInfo.address;
                            data.localPort = localInfo.port;
                            data.localFamily = localInfo.family;
                  }
                          if (clientHandle.getpeername) {
                            const remoteInfo = ObjectCreate(null);
                            clientHandle.getpeername(remoteInfo);
                            data.remoteAddress = remoteInfo.address;
                            data.remotePort = remoteInfo.port;
                            data.remoteFamily = remoteInfo.family;
                  }
                          self.emit('drop', data);
                } else {
                          self.emit('drop');
                }
                        clientHandle.close();
                        return;
              }

                      const socket = new Socket({
                        handle: clientHandle,
                        allowHalfOpen: self.allowHalfOpen,
                        pauseOnCreate: self.pauseOnConnect,
                        readable: true,
                        writable: true,
                        readableHighWaterMark: self.highWaterMark,
                        writableHighWaterMark: self.highWaterMark,
              });

                      if (self.noDelay && clientHandle.setNoDelay) {
                        socket[kSetNoDelay
                ] = true;
                        clientHandle.setNoDelay(true);
              }
                      if (self.keepAlive && clientHandle.setKeepAlive) {
                        socket[kSetKeepAlive
                ] = true;
                        socket[kSetKeepAliveInitialDelay
                ] = self.keepAliveInitialDelay;
                        clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
              }

                      self._connections++;
                      socket.server = self;
                      socket._server = self;

                      DTRACE_NET_SERVER_CONNECTION(socket);
                      self.emit('connection', socket);
                      lazyChannels();
                      if (netServerSocketChannel.hasSubscribers) {
                        netServerSocketChannel.publish({
                          socket,
                });
              }
            },
          },
                _usingWorkers: false,
                  _workers: [],
                    _unref: false,
                      allowHalfOpen: true,
                        pauseOnConnect: false,
                          noDelay: true,
                            keepAlive: false,
                              keepAliveInitialDelay: 0,
                                highWaterMark: 16384,
                                  httpAllowHalfOpen: false,
                                    timeout: 0,
                                      maxHeadersCount: null,
                                        maxRequestsPerSocket: 0,
                                          _connectionKey: "6::::1394",
        },
              _server: {
                maxHeaderSize: undefined,
                  insecureHTTPParser: undefined,
                    requestTimeout: 300000,
                      headersTimeout: 60000,
                        keepAliveTimeout: 5000,
                          connectionsCheckingInterval: 30000,
                            joinDuplicateHeaders: undefined,
                              rejectNonStandardBodyWrites: false,
                                _events: {
                  request: function(req, res, next) {
                    app.handle(req, res, next);
            },
                  connection: function connectionListener(socket) {
                    defaultTriggerAsyncIdScope(
                      getOrSetAsyncId(socket), connectionListenerInternal, this, socket,
                    );
            },
                  listening: [
                    function setupConnectionsTracking() {
                // Start connection handling
                      if (!this[kConnections
                ]) {
                        this[kConnections
                  ] = new ConnectionsList();
                }
                // This checker is started without checking whether any headersTimeout or requestTimeout is non zero
                // otherwise it would not be started if such timeouts are modified after createServer.
                      this[kConnectionsCheckingInterval
                ] =
                        setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
              },
                    function () {
                [native code
                ]
              },
            ],
                    error: function () {
              [native code
              ]
            },
                  upgrade: (req, socket, head) => {
                    this.handleUpgrade(req, socket, head, emitConnection);
            },
          },
                _eventsCount: 5,
                  _maxListeners: undefined,
                    _connections: 1,
                      _handle: {
                  reading: false,
                    onconnection: function onconnection(err, clientHandle) {
                      const handle = this;
                      const self = handle[owner_symbol
              ];

                      debug('onconnection');

                      if (err) {
                        self.emit('error', errnoException(err, 'accept'));
                        return;
              }

                      if (self.maxConnections && self._connections >= self.maxConnections) {
                        if (clientHandle.getsockname || clientHandle.getpeername) {
                          const data = ObjectCreate(null);
                          if (clientHandle.getsockname) {
                            const localInfo = ObjectCreate(null);
                            clientHandle.getsockname(localInfo);
                            data.localAddress = localInfo.address;
                            data.localPort = localInfo.port;
                            data.localFamily = localInfo.family;
                  }
                          if (clientHandle.getpeername) {
                            const remoteInfo = ObjectCreate(null);
                            clientHandle.getpeername(remoteInfo);
                            data.remoteAddress = remoteInfo.address;
                            data.remotePort = remoteInfo.port;
                            data.remoteFamily = remoteInfo.family;
                  }
                          self.emit('drop', data);
                } else {
                          self.emit('drop');
                }
                        clientHandle.close();
                        return;
              }

                      const socket = new Socket({
                        handle: clientHandle,
                        allowHalfOpen: self.allowHalfOpen,
                        pauseOnCreate: self.pauseOnConnect,
                        readable: true,
                        writable: true,
                        readableHighWaterMark: self.highWaterMark,
                        writableHighWaterMark: self.highWaterMark,
              });

                      if (self.noDelay && clientHandle.setNoDelay) {
                        socket[kSetNoDelay
                ] = true;
                        clientHandle.setNoDelay(true);
              }
                      if (self.keepAlive && clientHandle.setKeepAlive) {
                        socket[kSetKeepAlive
                ] = true;
                        socket[kSetKeepAliveInitialDelay
                ] = self.keepAliveInitialDelay;
                        clientHandle.setKeepAlive(true, self.keepAliveInitialDelay);
              }

                      self._connections++;
                      socket.server = self;
                      socket._server = self;

                      DTRACE_NET_SERVER_CONNECTION(socket);
                      self.emit('connection', socket);
                      lazyChannels();
                      if (netServerSocketChannel.hasSubscribers) {
                        netServerSocketChannel.publish({
                          socket,
                });
              }
            },
          },
                _usingWorkers: false,
                  _workers: [],
                    _unref: false,
                      allowHalfOpen: true,
                        pauseOnConnect: false,
                          noDelay: true,
                            keepAlive: false,
                              keepAliveInitialDelay: 0,
                                highWaterMark: 16384,
                                  httpAllowHalfOpen: false,
                                    timeout: 0,
                                      maxHeadersCount: null,
                                        maxRequestsPerSocket: 0,
                                          _connectionKey: "6::::1394",
        },
              parser: {
          "0": null,
          "1": function parserOnHeaders(headers, url) {
            // Once we exceeded headers limit - stop collecting them
                    if (this.maxHeaderPairs <= 0 ||
                      this._headers.length < this.maxHeaderPairs) {
                      this._headers.push(...headers);
            }
                    this._url += url;
          },
          "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                  url, statusCode, statusMessage, upgrade,
                  shouldKeepAlive) {
                  const parser = this;
                  const { socket
            } = parser;

                  if (headers === undefined) {
                    headers = parser._headers;
                    parser._headers = [];
            }

                  if (url === undefined) {
                    url = parser._url;
                    parser._url = '';
            }
            // Parser is also used by http client
                  const ParserIncomingMessage = (socket && socket.server &&
                    socket.server[kIncomingMessage
            ]) ||
                    IncomingMessage;

                  const incoming = parser.incoming = new ParserIncomingMessage(socket);
                  incoming.httpVersionMajor = versionMajor;
                  incoming.httpVersionMinor = versionMinor;
                  incoming.httpVersion = `${versionMajor
            }.${versionMinor
            }`;
                  incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
                    parser.joinDuplicateHeaders;
                  incoming.url = url;
                  incoming.upgrade = upgrade;

                  let n = headers.length;

                  // If parser.maxHeaderPairs <= 0 assume that there's no limit.
                  if (parser.maxHeaderPairs > 0)
                    n = MathMin(n, parser.maxHeaderPairs);

                  incoming._addHeaderLines(headers, n);

                  if (typeof method === 'number') {
              // server only
                    incoming.method = methods[method
              ];
            } else {
              // client only
                    incoming.statusCode = statusCode;
                    incoming.statusMessage = statusMessage;
            }

                  return parser.onIncoming(incoming, shouldKeepAlive);
          },
          "3": function parserOnBody(b) {
                  const stream = this.incoming;

                  // If the stream has already been removed, then drop it.
                  if (stream === null)
                    return;

                  // Pretend this was the result of a stream._read call.
                  if (!stream._dumped) {
                    const ret = stream.push(b);
                    if (!ret)
                      readStop(this.socket);
            }
          },
          "4": function parserOnMessageComplete() {
                  const parser = this;
                  const stream = parser.incoming;

                  if (stream !== null) {
                    stream.complete = true;
                    // Emit any trailing headers.
                    const headers = parser._headers;
                    if (headers.length) {
                      stream._addHeaderLines(headers, headers.length);
                      parser._headers = [];
                      parser._url = '';
              }
              // For emit end event
                    stream.push(null);
            }
            // Force to read the next incoming message
                  readStart(parser.socket);
          },
          "5": function () {
            [native code
            ]
          },
          "6": function () {
            [native code
            ]
          },
                _headers: [],
                  _url: "",
                    socket: [Circular
          ],
                      incoming: [Circular
          ],
                        outgoing: null,
                          maxHeaderPairs: 2000,
                            _consumed: true,
                              onIncoming: function () {
            [native code
            ]
          },
                joinDuplicateHeaders: null,
        },
              on: function socketListenerWrap(ev, fn) {
                const res = net.Socket.prototype[originalFnName
          ].call(this,
                  ev, fn);
                if (!this.parser) {
                  this.on = net.Socket.prototype.on;
                  this.addListener = net.Socket.prototype.addListener;
                  this.prependListener = net.Socket.prototype.prependListener;
                  return res;
          }

                if (ev === 'data' || ev === 'readable')
                  unconsume(this.parser, this);

                return res;
        },
              addListener: function socketListenerWrap(ev, fn) {
                const res = net.Socket.prototype[originalFnName
          ].call(this,
                  ev, fn);
                if (!this.parser) {
                  this.on = net.Socket.prototype.on;
                  this.addListener = net.Socket.prototype.addListener;
                  this.prependListener = net.Socket.prototype.prependListener;
                  return res;
          }

                if (ev === 'data' || ev === 'readable')
                  unconsume(this.parser, this);

                return res;
        },
              prependListener: function socketListenerWrap(ev, fn) {
                const res = net.Socket.prototype[originalFnName
          ].call(this,
                  ev, fn);
                if (!this.parser) {
                  this.on = net.Socket.prototype.on;
                  this.addListener = net.Socket.prototype.addListener;
                  this.prependListener = net.Socket.prototype.prependListener;
                  return res;
          }

                if (ev === 'data' || ev === 'readable')
                  unconsume(this.parser, this);

                return res;
        },
              setEncoding: function socketSetEncoding() {
                throw new ERR_HTTP_SOCKET_ENCODING();
        },
              _paused: false,
                _httpMessage: [Circular
        ],
                  _peername: {
                address: "::1",
                  family: "IPv6",
                    port: 56041,
        },
      },
            _consuming: false,
              _dumped: false,
                next: function next(err) {
                  var layerError = err === 'route'
                    ? null
                    : err;

                  // remove added slash
                  if (slashAdded) {
                    req.url = req.url.slice(1)
                    slashAdded = false;
        }
        // restore altered req.url
                  if (removed.length !== 0) {
                    req.baseUrl = parentUrl;
                    req.url = protohost + removed + req.url.slice(protohost.length)
                    removed = '';
        }
        // signal to exit router
                  if (layerError === 'router') {
                    setImmediate(done, null)
                    return
        }
        // no more matching layers
                  if (idx >= stack.length) {
                    setImmediate(done, layerError);
                    return;
        }
        // max sync stack
                  if (++sync > 100) {
                    return setImmediate(next, err)
        }
        // get pathname of request
                  var path = getPathname(req);

                  if (path == null) {
                    return done(layerError);
        }
        // find next matching layer
                  var layer;
                  var match;
                  var route;

                  while (match !== true && idx < stack.length) {
                    layer = stack[idx++
          ];
                    match = matchLayer(layer, path);
                    route = layer.route;

                    if (typeof match !== 'boolean') {
            // hold on to layerError
                      layerError = layerError || match;
          }

                    if (match !== true) {
                      continue;
          }

                    if (!route) {
            // process non-route handlers normally
                      continue;
          }

                    if (layerError) {
            // routes do not match with a pending error
                      match = false;
                      continue;
          }

                    var method = req.method;
                    var has_method = route._handles_method(method);

                    // build up automatic options response
                    if (!has_method && method === 'OPTIONS') {
                      appendMethods(options, route._options());
          }
          // don't even bother matching route
                    if (!has_method && method !== 'HEAD') {
                      match = false;
          }
        }
        // no match
                  if (match !== true) {
                    return done(layerError);
        }
        // store route for dispatch on change
                  if (route) {
                    req.route = route;
        }
        // Capture one-time layer values
                  req.params = self.mergeParams
                    ? mergeParams(layer.params, parentParams)
                    : layer.params;
                  var layerPath = layer.path;

                  // this should be done for the layer
                  self.process_params(layer, paramcalled, req, res, function (err) {
                    if (err) {
                      next(layerError || err)
          } else if (route) {
                      layer.handle_request(req, res, next)
          } else {
                      trim_prefix(layer, layerError, layerPath, path)
          }

                    sync = 0
        });
      },
            baseUrl: "",
              originalUrl: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                _parsedUrl: {
              protocol: null,
                slashes: null,
                  auth: null,
                    host: null,
                      port: null,
                        hostname: null,
                          hash: null,
                            search: "?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                              query: "usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                pathname: "/parseUserMe",
                                  path: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                    href: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
                                      _raw: "/parseUserMe?usersession=r:255111ff859d0977bb5b94ce2782d69d&include=entity",
      },
            params: {},
            query: {
              usersession: "r:255111ff859d0977bb5b94ce2782d69d",
                include: "entity",
      },
            res: [Circular
      ],
              body: {},
            route: {
              path: "/parseuserme",
                stack: [
          {
                    handle: (req, res, next) => {
                      let key = '__express__' + req.originalUrl || req.url
                      let cachedBody = mcache.get(key)
                      if (cachedBody) {
                        res.send(cachedBody)
                        return
              } else {
                        res.sendResponse = res.send
                        res.send = (body) => {
                          mcache.put(key, body, duration * 1000);
                          res.sendResponse(body)
                }
                        next()
              }
            },
                    name: "<anonymous>",
                    params: undefined,
                    path: undefined,
                    keys: [],
                    regexp: {
                      fast_star: false,
                      fast_slash: false,
            },
                    method: "get",
          },
          {
                    handle: async (request, response, next) => {
                      try {
                        await Promise.resolve(fn(request, response, next)).catch(next);
              } catch (error) {
                        next(error);
              }
            },
                    name: "<anonymous>",
                    params: undefined,
                    path: undefined,
                    keys: [],
                    regexp: {
                      fast_star: false,
                      fast_slash: false,
            },
                    method: "get",
          },
          {
                    handle: async (request, response, next) => {
                      await doHandle({ handler, request, response, next
              })
            },
                    name: "<anonymous>",
                    params: undefined,
                    path: undefined,
                    keys: [],
                    regexp: {
                      fast_star: false,
                      fast_slash: false,
            },
                    method: "get",
          },
        ],
                  methods: {
                get: true,
        },
      },
            rateLimit: {
              limit: 1000,
                used: 1,
                  remaining: 999,
                    resetTime: "2024-07-19T11:30:07.125Z",
      },
    },
          _sent100: false,
            _expect_continue: false,
              _maxRequestsPerSocket: 0,
                locals: {},
          flush: function flush() {
            if (stream) {
              stream.flush()
      }
    },
          write: function write(chunk, encoding) {
            if (ended) {
              return false
      }

            if (!this._header) {
              this._implicitHeader()
      }

            return stream
              ? stream.write(toBuffer(chunk, encoding))
              : _write.call(this, chunk, encoding)
    },
          end: function end(chunk, encoding) {
            if (ended) {
              return false
      }

            if (!this._header) {
        // estimate the length
              if (!this.getHeader('Content-Length')) {
                length = chunkLength(chunk, encoding)
        }

              this._implicitHeader()
      }

            if (!stream) {
              return _end.call(this, chunk, encoding)
      }
      // mark ended
            ended = true
      // write Buffer for Node.js 0.8
            return chunk
              ? stream.end(toBuffer(chunk, encoding))
              : stream.end()
    },
          on: function on(type, listener) {
            if (!listeners || type !== 'drain') {
              return _on.call(this, type, listener)
      }

            if (stream) {
              return stream.on(type, listener)
      }
      // buffer listeners for future stream
            listeners.push([type, listener
      ])

            return this
    },
          writeHead: function writeHead(statusCode) {
      // set headers from arguments
            var args = setWriteHeadHeaders.apply(this, arguments)

            // fire listener
            if (!fired) {
              fired = true
              listener.call(this)

              // pass-along an updated status code
              if (typeof args[
          0
        ] === 'number' && this.statusCode !== args[
          0
        ]) {
                args[
            0
          ] = this.statusCode
                args.length = 1
        }
      }

            return prevWriteHead.apply(this, args)
    },
          sendResponse: function send(body) {
            var chunk = body;
            var encoding;
            var req = this.req;
            var type;

            // settings
            var app = this.app;

            // allow status / body
            if (arguments.length === 2) {
        // res.send(body, status) backwards compat
              if (typeof arguments[
          0
        ] !== 'number' && typeof arguments[
          1
        ] === 'number') {
                deprecate('res.send(body, status): Use res.status(status).send(body) instead');
                this.statusCode = arguments[
            1
          ];
        } else {
                deprecate('res.send(status, body): Use res.status(status).send(body) instead');
                this.statusCode = arguments[
            0
          ];
                chunk = arguments[
            1
          ];
        }
      }
      // disambiguate res.send(status) and res.send(status, num)
            if (typeof chunk === 'number' && arguments.length === 1) {
        // res.send(status) will set status message as text string
              if (!this.get('Content-Type')) {
                this.type('txt');
        }

              deprecate('res.send(status): Use res.sendStatus(status) instead');
              this.statusCode = chunk;
              chunk = statuses.message[chunk
        ]
      }

            switch (typeof chunk) {
        // string defaulting to html
              case 'string':
                if (!this.get('Content-Type')) {
                  this.type('html');
        }
                break;
              case 'boolean':
              case 'number':
              case 'object':
                if (chunk === null) {
                  chunk = '';
        } else if (Buffer.isBuffer(chunk)) {
                  if (!this.get('Content-Type')) {
                    this.type('bin');
          }
        } else {
                  return this.json(chunk);
        }
                break;
      }
      // write strings in utf-8
            if (typeof chunk === 'string') {
              encoding = 'utf8';
              type = this.get('Content-Type');

              // reflect this in content-type
              if (typeof type === 'string') {
                this.set('Content-Type', setCharset(type, 'utf-8'));
        }
      }
      // determine if ETag should be generated
            var etagFn = app.get('etag fn')
            var generateETag = !this.get('ETag') && typeof etagFn === 'function'

            // populate Content-Length
            var len
            if (chunk !== undefined) {
              if (Buffer.isBuffer(chunk)) {
          // get length of Buffer
                len = chunk.length
        } else if (!generateETag && chunk.length < 1000) {
          // just calculate length when no ETag + small chunk
                len = Buffer.byteLength(chunk, encoding)
        } else {
          // convert chunk to Buffer and calculate
                chunk = Buffer.from(chunk, encoding)
                encoding = undefined;
                len = chunk.length
        }

              this.set('Content-Length', len);
      }
      // populate ETag
            var etag;
            if (generateETag && len !== undefined) {
              if ((etag = etagFn(chunk, encoding))) {
                this.set('ETag', etag);
        }
      }
      // freshness
            if (req.fresh) this.statusCode = 304;

            // strip irrelevant headers
            if (204 === this.statusCode || 304 === this.statusCode) {
              this.removeHeader('Content-Type');
              this.removeHeader('Content-Length');
              this.removeHeader('Transfer-Encoding');
              chunk = '';
      }
      // alter headers for 205
            if (this.statusCode === 205) {
              this.set('Content-Length', '0')
              this.removeHeader('Transfer-Encoding')
              chunk = ''
      }

            if (req.method === 'HEAD') {
        // skip body for HEAD
              this.end();
      } else {
        // respond
              this.end(chunk, encoding);
      }

            return this;
    },
          send: (body) => {
            mcache.put(key, body, duration * 1000);
            res.sendResponse(body)
    },
  },
        body: {},
        route: {
          path: "/parseuserme",
            stack: [
      {
                handle: (req, res, next) => {
                  let key = '__express__' + req.originalUrl || req.url
                  let cachedBody = mcache.get(key)
                  if (cachedBody) {
                    res.send(cachedBody)
                    return
          } else {
                    res.sendResponse = res.send
                    res.send = (body) => {
                      mcache.put(key, body, duration * 1000);
                      res.sendResponse(body)
            }
                    next()
          }
        },
                name: "<anonymous>",
                params: undefined,
                path: undefined,
                keys: [],
                regexp: {
                  fast_star: false,
                  fast_slash: false,
        },
                method: "get",
      },
      {
                handle: async (request, response, next) => {
                  try {
                    await Promise.resolve(fn(request, response, next)).catch(next);
          } catch (error) {
                    next(error);
          }
        },
                name: "<anonymous>",
                params: undefined,
                path: undefined,
                keys: [],
                regexp: {
                  fast_star: false,
                  fast_slash: false,
        },
                method: "get",
      },
      {
                handle: async (request, response, next) => {
                  await doHandle({ handler, request, response, next
          })
        },
                name: "<anonymous>",
                params: undefined,
                path: undefined,
                keys: [],
                regexp: {
                  fast_star: false,
                  fast_slash: false,
        },
                method: "get",
      },
    ],
              methods: {
            get: true,
    },
  },
        rateLimit: {
          limit: 1000,
            used: 1,
              remaining: 999,
                resetTime: "2024-07-19T11:30:07.125Z",
  },
}